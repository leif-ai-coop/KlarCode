{"ast":null,"code":"/**\r\n * Validate an ICD-10 code format\r\n * @param {string} code - The code to validate\r\n * @returns {boolean} - True if valid format, false otherwise\r\n */\nexport const isValidICDFormat = code => {\n  // Format: A00 or A00.0\n  return /^[A-Z]\\d{2}(\\.\\d+)?$/.test(code);\n};\n\n/**\r\n * Validate an OPS code format\r\n * @param {string} code - The code to validate\r\n * @returns {boolean} - True if valid format, false otherwise\r\n */\nexport const isValidOPSFormat = code => {\n  // Erweiterte Validierung für OPS-Codes:\n  // - Beginnt mit Ziffer-Bindestrich-Ziffern: \\d-\\d+\n  // - Kann Buchstaben im Hauptteil haben: [a-z]*\n  // - Kann optional einen Punkt haben, gefolgt von:\n  //   - Ziffern und/oder Buchstaben: [a-z0-9]+\n  // \n  // Beispiele:\n  // - 1-20 (einfacher Code)\n  // - 1-202.00 (Code mit Dezimalstelle)\n  // - 1-20a.31 (Code mit Buchstabe und Dezimalstelle)\n  // - 1-20b (Code mit Buchstabe ohne Dezimalstelle)\n  // - 1-20c.x, 1-20c.y (Code mit Buchstaben nach dem Punkt)\n  return /^\\d-\\d+[a-z]*(\\.[a-z0-9]+)?$/i.test(code);\n};\n\n/**\r\n * Format an OPS code by:\r\n * 1. Inserting a hyphen after the first digit if missing\r\n * 2. Inserting a dot at the correct position if missing\r\n * @param {string} code - The OPS code to format\r\n * @returns {string} - Properly formatted OPS code\r\n */\nexport const formatOPSCode = code => {\n  // Bereits formatiert (hat Bindestrich und Punkt)\n  if (code.includes('-') && code.includes('.')) {\n    return code;\n  }\n\n  // Kein Bindestrich vorhanden, aber beginnt mit einer Ziffer\n  if (!code.includes('-') && /^\\d/.test(code)) {\n    // Bindestrich nach der ersten Ziffer einfügen\n    code = code.replace(/^(\\d)/, '$1-');\n  }\n\n  // Wenn kein Punkt vorhanden ist\n  if (!code.includes('.') && /^\\d-\\d+/.test(code)) {\n    // Typisches Format bei OPS-Codes:\n    // 5-787 -> keine Änderung nötig (es gibt keine Nachkommastelle)\n    // 5-7870h -> sollte 5-787.0h werden\n    // 5-78701 -> sollte 5-787.01 werden\n\n    // Regulärer Ausdruck für den Teil nach dem Bindestrich\n    // Wir suchen 3 Ziffern, gefolgt von mindestens einer weiteren Ziffer\n    const match = code.match(/^\\d-(\\d{3})(\\d+[a-zA-Z]*)$/);\n    if (match) {\n      // Der erste Teil des Codes (z.B. \"5-787\")\n      const basePart = code.substring(0, match[0].indexOf(match[2]));\n      // Der Rest des Codes, der nach dem Punkt kommen soll (z.B. \"0h\")\n      const decimalPart = match[2];\n      code = basePart + '.' + decimalPart;\n    }\n  }\n  return code;\n};\n\n/**\r\n * Normalize a code by removing non-alphanumeric characters\r\n * @param {string} code - The code to normalize\r\n * @returns {string} - Normalized code\r\n */\nexport const normalizeCode = code => {\n  // Keep only alphanumeric characters and dots\n  return code.replace(/[^A-Za-z0-9.-]/g, '');\n};\n\n/**\r\n * Parse user input into an array of codes\r\n * @param {string} input - User input\r\n * @returns {string[]} - Array of individual codes\r\n */\nexport const parseUserInput = input => {\n  // Split by comma, semicolon, newline, or space\n  const codes = input.split(/[,;\\n\\s]+/).map(code => code.trim()).filter(code => code.length > 0);\n\n  // Remove duplicates\n  const uniqueCodes = [...new Set(codes)];\n  const duplicatesRemoved = codes.length - uniqueCodes.length;\n  return {\n    codes: uniqueCodes,\n    duplicatesRemoved\n  };\n};\n\n/**\r\n * Check if a code is a wildcard search\r\n * @param {string} code - The code to check\r\n * @returns {boolean} - True if wildcard, false otherwise\r\n */\nexport const isWildcardSearch = code => {\n  // Sowohl * als auch % als Wildcard-Zeichen erkennen\n  return code.includes('*') || code.includes('%');\n};\n\n/**\r\n * Convert wildcard pattern to regex\r\n * @param {string} pattern - Wildcard pattern\r\n * @returns {RegExp} - Regular expression\r\n */\nexport const wildcardToRegex = pattern => {\n  // Ersetze sowohl * als auch % mit regex .*\n  const regexPattern = pattern.replace(/\\*/g, '.*').replace(/%/g, '.*');\n  return new RegExp(`^${regexPattern}$`);\n};\n\n/**\r\n * Find all codes matching a wildcard pattern\r\n * @param {string} pattern - Wildcard pattern\r\n * @param {Object} codeMap - Map of all codes\r\n * @returns {string[]} - Array of matching codes\r\n */\nexport const findWildcardMatches = (pattern, codeMap) => {\n  const regex = wildcardToRegex(pattern);\n  return Object.keys(codeMap).filter(code => {\n    return regex.test(code);\n  });\n};\n\n/**\r\n * Find all child codes for a non-terminal ICD code\r\n * @param {string} parentCode - The parent code\r\n * @param {Object} codeMap - Map of all codes\r\n * @returns {string[]} - Array of child codes\r\n */\nexport const findChildICDCodes = (parentCode, codeMap) => {\n  // Für einen Code wie A04, finde alle Codes, die mit A04. beginnen\n  const childPattern = `${parentCode}.`;\n  const childCodes = Object.keys(codeMap).filter(code => {\n    // Entweder beginnt der Code mit dem gesuchten Muster...\n    return code.startsWith(childPattern) ||\n    // ...oder es handelt sich um einen exakten Match, der als nicht-endstellig markiert ist\n    code === parentCode && codeMap[code].isNonTerminal;\n  });\n  console.log(`Finding child codes for ${parentCode}, found ${childCodes.length} children`);\n  return childCodes;\n};\n\n/**\r\n * Find all child codes for a non-terminal OPS code\r\n * @param {string} parentCode - The parent code\r\n * @param {Object} codeMap - Map of all codes\r\n * @returns {string[]} - Array of child codes\r\n */\nexport const findChildOPSCodes = (parentCode, codeMap) => {\n  // Verschiedene Arten von Kindcodes bei OPS:\n  // 1. Codes, die mit dem Elterncode + Punkt beginnen: 1-20.0, 1-20.1 für 1-20\n  // 2. Codes, die mit dem Elterncode + Buchstabe beginnen: 1-20a, 1-20b für 1-20\n  // 3. Codes, die mit dem Elterncode + Buchstabe + Punkt beginnen: 1-20a.31 für 1-20a\n\n  const childCodes = Object.keys(codeMap).filter(code => {\n    // Exakter Match, aber als nicht-endstellig markiert\n    if (code === parentCode && codeMap[code].isNonTerminal) {\n      return true;\n    }\n\n    // Kindcodes, die mit dem Elterncode beginnen\n    if (code !== parentCode && (code.startsWith(parentCode + '.') || code.startsWith(parentCode) && /[a-z]/i.test(code.substring(parentCode.length, parentCode.length + 1)))) {\n      return true;\n    }\n    return false;\n  });\n  console.log(`Finding child codes for OPS ${parentCode}, found ${childCodes.length} children`);\n  return childCodes;\n};\n\n/**\r\n * Find the chapter for an ICD code\r\n * @param {string} code - The ICD code\r\n * @param {Object} codeMap - Map of all ICD codes\r\n * @param {Object} chaptersMap - Map of chapters\r\n * @returns {string} - Chapter description or empty string if not found\r\n */\nexport const findICDChapter = (code, codeMap, chaptersMap) => {\n  if (!codeMap[code]) return '';\n\n  // Extract chapter ID from the code metadata\n  // In ICD files, the chapter ID is typically in format \"01\"\n  // We'd need to extract this from the actual data structure based on your file format\n  // This is a placeholder implementation\n  const chapterId = code.startsWith('A') || code.startsWith('B') ? '01' : code.startsWith('C') || code.startsWith('D') ? '02' : '';\n  return chaptersMap[chapterId] ? chaptersMap[chapterId].description : '';\n};\n\n/**\r\n * Find the group for an ICD code\r\n * @param {string} code - The ICD code\r\n * @param {Object} groupsMap - Map of groups\r\n * @returns {string} - Group description or empty string if not found\r\n */\nexport const findICDGroup = (code, groupsMap) => {\n  // Extract the base code (A00 from A00.1)\n  const baseCode = code.split('.')[0];\n\n  // Find the group where the code falls between start and end\n  for (const groupKey in groupsMap) {\n    const group = groupsMap[groupKey];\n    if (baseCode >= group.start && baseCode <= group.end) {\n      return group.description;\n    }\n  }\n  return '';\n};\n\n/**\r\n * Find the chapter for an OPS code\r\n * @param {string} code - The OPS code\r\n * @param {Object} chaptersMap - Map of chapters\r\n * @returns {string} - Chapter description or empty string if not found\r\n */\nexport const findOPSChapter = (code, chaptersMap) => {\n  // OPS codes start with the chapter number, e.g., \"1-20\" is in chapter \"1\"\n  const chapterId = code.split('-')[0];\n  return chaptersMap[chapterId] ? chaptersMap[chapterId].description : '';\n};\n\n/**\r\n * Find the group for an OPS code\r\n * @param {string} code - The OPS code\r\n * @param {Object} groupsMap - Map of groups\r\n * @returns {string} - Group description or empty string if not found\r\n */\nexport const findOPSGroup = (code, groupsMap) => {\n  // Extract base code (1-20 from 1-202.00)\n  const parts = code.split('.');\n  let baseCode = parts[0];\n\n  // If it's a detailed code like 1-202, we need the base group like 1-20\n  if (baseCode.match(/\\d-\\d{3}/)) {\n    baseCode = baseCode.substring(0, 4); // Get 1-20 from 1-202\n  }\n\n  // Find the exact group or a parent group\n  if (groupsMap[baseCode]) {\n    return groupsMap[baseCode].description;\n  }\n\n  // If not found, try to find a parent group\n  for (const groupKey in groupsMap) {\n    if (baseCode.startsWith(groupKey)) {\n      return groupsMap[groupKey].description;\n    }\n  }\n  return '';\n};\n\n/**\r\n * Find the three-digit code for an OPS code\r\n * @param {string} code - The OPS code\r\n * @param {Object} dreistellerMap - Map of three-digit codes\r\n * @returns {string} - Three-digit code description or empty string if not found\r\n */\nexport const findOPSDreisteller = (code, dreistellerMap) => {\n  // Extract the three-digit part from codes like 1-202.00 -> 1-202\n  const dreistellerCode = code.split('.')[0];\n  if (dreistellerMap[dreistellerCode]) {\n    return dreistellerMap[dreistellerCode].description;\n  }\n\n  // If not found, it might be a parent code itself\n  if (dreistellerCode.match(/\\d-\\d{2}$/)) {\n    return dreistellerMap[dreistellerCode] ? dreistellerMap[dreistellerCode].description : '';\n  }\n  return '';\n};\n\n/**\r\n * Erkennt, ob ein Code ein ICD oder OPS Code ist\r\n * @param {string} code - Der zu prüfende Code\r\n * @returns {string} - 'icd', 'ops' oder 'unknown'\r\n */\nexport const detectCodeType = code => {\n  // Normalisieren\n  const normalized = normalizeCode(code);\n\n  // Wenn der Code mit einem Buchstaben beginnt, ist es ein ICD-Code\n  if (/^[A-Z]/.test(normalized)) {\n    return 'icd';\n  }\n\n  // Wenn der Code mit einer Zahl beginnt, ist es ein OPS-Code\n  if (/^\\d/.test(normalized)) {\n    return 'ops';\n  }\n\n  // Wenn nichts zutrifft, ist der Typ unbekannt\n  return 'unknown';\n};\n\n/**\r\n * Prüft, ob eine Liste von Codes gemischte Typen enthält\r\n * @param {Array<string>} codes - Liste der zu prüfenden Codes\r\n * @returns {Object} - Enthält Informationen über die erkannten Codetypen\r\n */\nexport const analyzeCodeTypes = codes => {\n  let hasICD = false;\n  let hasOPS = false;\n  let unknownCodes = [];\n  for (const code of codes) {\n    const type = detectCodeType(code);\n    if (type === 'icd') {\n      hasICD = true;\n    } else if (type === 'ops') {\n      hasOPS = true;\n    } else {\n      unknownCodes.push(code);\n    }\n  }\n  return {\n    hasICD,\n    hasOPS,\n    unknownCodes,\n    isMixed: hasICD && hasOPS,\n    type: hasICD && !hasOPS ? 'icd' : !hasICD && hasOPS ? 'ops' : 'mixed'\n  };\n};\n\n/**\r\n * Findet den Dreisteller-Bereich für einen OPS-Code\r\n * @param {string} code - Der OPS-Code\r\n * @param {Object} dreistellerMap - Map der Dreisteller-Bereiche\r\n * @returns {Object} - Dreisteller-Informationen oder null wenn nicht gefunden\r\n */\nexport const findDreistellerRange = (code, dreistellerMap) => {\n  // Direkter Lookup für einzelne Dreisteller-Codes\n  if (dreistellerMap[code]) {\n    return dreistellerMap[code];\n  }\n\n  // Extrahiere den Dreisteller-Teil (z.B. \"5-59\" aus \"5-590\")\n  const match = code.match(/^(\\d-\\d{2})/);\n  if (match) {\n    const dreistellerCode = match[1];\n    if (dreistellerMap[dreistellerCode]) {\n      return dreistellerMap[dreistellerCode];\n    }\n  }\n\n  // Finde den passenden Bereich\n  for (const rangeKey in dreistellerMap) {\n    if (rangeKey.includes('-') && !dreistellerMap[rangeKey].isPartOfRange) {\n      const [startCode, endCode] = rangeKey.split('-');\n      if (code >= startCode && code <= endCode) {\n        return dreistellerMap[rangeKey];\n      }\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["isValidICDFormat","code","test","isValidOPSFormat","formatOPSCode","includes","replace","match","basePart","substring","indexOf","decimalPart","normalizeCode","parseUserInput","input","codes","split","map","trim","filter","length","uniqueCodes","Set","duplicatesRemoved","isWildcardSearch","wildcardToRegex","pattern","regexPattern","RegExp","findWildcardMatches","codeMap","regex","Object","keys","findChildICDCodes","parentCode","childPattern","childCodes","startsWith","isNonTerminal","console","log","findChildOPSCodes","findICDChapter","chaptersMap","chapterId","description","findICDGroup","groupsMap","baseCode","groupKey","group","start","end","findOPSChapter","findOPSGroup","parts","findOPSDreisteller","dreistellerMap","dreistellerCode","detectCodeType","normalized","analyzeCodeTypes","hasICD","hasOPS","unknownCodes","type","push","isMixed","findDreistellerRange","rangeKey","isPartOfRange","startCode","endCode"],"sources":["C:/Code/KlarCode/src/utils/search.js"],"sourcesContent":["/**\r\n * Validate an ICD-10 code format\r\n * @param {string} code - The code to validate\r\n * @returns {boolean} - True if valid format, false otherwise\r\n */\r\nexport const isValidICDFormat = (code) => {\r\n  // Format: A00 or A00.0\r\n  return /^[A-Z]\\d{2}(\\.\\d+)?$/.test(code);\r\n};\r\n\r\n/**\r\n * Validate an OPS code format\r\n * @param {string} code - The code to validate\r\n * @returns {boolean} - True if valid format, false otherwise\r\n */\r\nexport const isValidOPSFormat = (code) => {\r\n  // Erweiterte Validierung für OPS-Codes:\r\n  // - Beginnt mit Ziffer-Bindestrich-Ziffern: \\d-\\d+\r\n  // - Kann Buchstaben im Hauptteil haben: [a-z]*\r\n  // - Kann optional einen Punkt haben, gefolgt von:\r\n  //   - Ziffern und/oder Buchstaben: [a-z0-9]+\r\n  // \r\n  // Beispiele:\r\n  // - 1-20 (einfacher Code)\r\n  // - 1-202.00 (Code mit Dezimalstelle)\r\n  // - 1-20a.31 (Code mit Buchstabe und Dezimalstelle)\r\n  // - 1-20b (Code mit Buchstabe ohne Dezimalstelle)\r\n  // - 1-20c.x, 1-20c.y (Code mit Buchstaben nach dem Punkt)\r\n  return /^\\d-\\d+[a-z]*(\\.[a-z0-9]+)?$/i.test(code);\r\n};\r\n\r\n/**\r\n * Format an OPS code by:\r\n * 1. Inserting a hyphen after the first digit if missing\r\n * 2. Inserting a dot at the correct position if missing\r\n * @param {string} code - The OPS code to format\r\n * @returns {string} - Properly formatted OPS code\r\n */\r\nexport const formatOPSCode = (code) => {\r\n  // Bereits formatiert (hat Bindestrich und Punkt)\r\n  if (code.includes('-') && code.includes('.')) {\r\n    return code;\r\n  }\r\n  \r\n  // Kein Bindestrich vorhanden, aber beginnt mit einer Ziffer\r\n  if (!code.includes('-') && /^\\d/.test(code)) {\r\n    // Bindestrich nach der ersten Ziffer einfügen\r\n    code = code.replace(/^(\\d)/, '$1-');\r\n  }\r\n  \r\n  // Wenn kein Punkt vorhanden ist\r\n  if (!code.includes('.') && /^\\d-\\d+/.test(code)) {\r\n    // Typisches Format bei OPS-Codes:\r\n    // 5-787 -> keine Änderung nötig (es gibt keine Nachkommastelle)\r\n    // 5-7870h -> sollte 5-787.0h werden\r\n    // 5-78701 -> sollte 5-787.01 werden\r\n    \r\n    // Regulärer Ausdruck für den Teil nach dem Bindestrich\r\n    // Wir suchen 3 Ziffern, gefolgt von mindestens einer weiteren Ziffer\r\n    const match = code.match(/^\\d-(\\d{3})(\\d+[a-zA-Z]*)$/);\r\n    \r\n    if (match) {\r\n      // Der erste Teil des Codes (z.B. \"5-787\")\r\n      const basePart = code.substring(0, match[0].indexOf(match[2]));\r\n      // Der Rest des Codes, der nach dem Punkt kommen soll (z.B. \"0h\")\r\n      const decimalPart = match[2];\r\n      \r\n      code = basePart + '.' + decimalPart;\r\n    }\r\n  }\r\n  \r\n  return code;\r\n};\r\n\r\n/**\r\n * Normalize a code by removing non-alphanumeric characters\r\n * @param {string} code - The code to normalize\r\n * @returns {string} - Normalized code\r\n */\r\nexport const normalizeCode = (code) => {\r\n  // Keep only alphanumeric characters and dots\r\n  return code.replace(/[^A-Za-z0-9.-]/g, '');\r\n};\r\n\r\n/**\r\n * Parse user input into an array of codes\r\n * @param {string} input - User input\r\n * @returns {string[]} - Array of individual codes\r\n */\r\nexport const parseUserInput = (input) => {\r\n  // Split by comma, semicolon, newline, or space\r\n  const codes = input.split(/[,;\\n\\s]+/)\r\n    .map(code => code.trim())\r\n    .filter(code => code.length > 0);\r\n  \r\n  // Remove duplicates\r\n  const uniqueCodes = [...new Set(codes)];\r\n  const duplicatesRemoved = codes.length - uniqueCodes.length;\r\n  \r\n  return {\r\n    codes: uniqueCodes,\r\n    duplicatesRemoved\r\n  };\r\n};\r\n\r\n/**\r\n * Check if a code is a wildcard search\r\n * @param {string} code - The code to check\r\n * @returns {boolean} - True if wildcard, false otherwise\r\n */\r\nexport const isWildcardSearch = (code) => {\r\n  // Sowohl * als auch % als Wildcard-Zeichen erkennen\r\n  return code.includes('*') || code.includes('%');\r\n};\r\n\r\n/**\r\n * Convert wildcard pattern to regex\r\n * @param {string} pattern - Wildcard pattern\r\n * @returns {RegExp} - Regular expression\r\n */\r\nexport const wildcardToRegex = (pattern) => {\r\n  // Ersetze sowohl * als auch % mit regex .*\r\n  const regexPattern = pattern\r\n    .replace(/\\*/g, '.*')\r\n    .replace(/%/g, '.*');\r\n  \r\n  return new RegExp(`^${regexPattern}$`);\r\n};\r\n\r\n/**\r\n * Find all codes matching a wildcard pattern\r\n * @param {string} pattern - Wildcard pattern\r\n * @param {Object} codeMap - Map of all codes\r\n * @returns {string[]} - Array of matching codes\r\n */\r\nexport const findWildcardMatches = (pattern, codeMap) => {\r\n  const regex = wildcardToRegex(pattern);\r\n  \r\n  return Object.keys(codeMap).filter(code => {\r\n    return regex.test(code);\r\n  });\r\n};\r\n\r\n/**\r\n * Find all child codes for a non-terminal ICD code\r\n * @param {string} parentCode - The parent code\r\n * @param {Object} codeMap - Map of all codes\r\n * @returns {string[]} - Array of child codes\r\n */\r\nexport const findChildICDCodes = (parentCode, codeMap) => {\r\n  // Für einen Code wie A04, finde alle Codes, die mit A04. beginnen\r\n  const childPattern = `${parentCode}.`;\r\n  \r\n  const childCodes = Object.keys(codeMap).filter(code => {\r\n    // Entweder beginnt der Code mit dem gesuchten Muster...\r\n    return code.startsWith(childPattern) ||\r\n           // ...oder es handelt sich um einen exakten Match, der als nicht-endstellig markiert ist\r\n           (code === parentCode && codeMap[code].isNonTerminal);\r\n  });\r\n  \r\n  console.log(`Finding child codes for ${parentCode}, found ${childCodes.length} children`);\r\n  return childCodes;\r\n};\r\n\r\n/**\r\n * Find all child codes for a non-terminal OPS code\r\n * @param {string} parentCode - The parent code\r\n * @param {Object} codeMap - Map of all codes\r\n * @returns {string[]} - Array of child codes\r\n */\r\nexport const findChildOPSCodes = (parentCode, codeMap) => {\r\n  // Verschiedene Arten von Kindcodes bei OPS:\r\n  // 1. Codes, die mit dem Elterncode + Punkt beginnen: 1-20.0, 1-20.1 für 1-20\r\n  // 2. Codes, die mit dem Elterncode + Buchstabe beginnen: 1-20a, 1-20b für 1-20\r\n  // 3. Codes, die mit dem Elterncode + Buchstabe + Punkt beginnen: 1-20a.31 für 1-20a\r\n  \r\n  const childCodes = Object.keys(codeMap).filter(code => {\r\n    // Exakter Match, aber als nicht-endstellig markiert\r\n    if (code === parentCode && codeMap[code].isNonTerminal) {\r\n      return true;\r\n    }\r\n    \r\n    // Kindcodes, die mit dem Elterncode beginnen\r\n    if (code !== parentCode && (\r\n        code.startsWith(parentCode + '.') || \r\n        code.startsWith(parentCode) && /[a-z]/i.test(code.substring(parentCode.length, parentCode.length + 1))\r\n    )) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  });\r\n  \r\n  console.log(`Finding child codes for OPS ${parentCode}, found ${childCodes.length} children`);\r\n  return childCodes;\r\n};\r\n\r\n/**\r\n * Find the chapter for an ICD code\r\n * @param {string} code - The ICD code\r\n * @param {Object} codeMap - Map of all ICD codes\r\n * @param {Object} chaptersMap - Map of chapters\r\n * @returns {string} - Chapter description or empty string if not found\r\n */\r\nexport const findICDChapter = (code, codeMap, chaptersMap) => {\r\n  if (!codeMap[code]) return '';\r\n  \r\n  // Extract chapter ID from the code metadata\r\n  // In ICD files, the chapter ID is typically in format \"01\"\r\n  // We'd need to extract this from the actual data structure based on your file format\r\n  // This is a placeholder implementation\r\n  const chapterId = code.startsWith('A') || code.startsWith('B') ? '01' : \r\n                    code.startsWith('C') || code.startsWith('D') ? '02' : '';\r\n  \r\n  return chaptersMap[chapterId] ? chaptersMap[chapterId].description : '';\r\n};\r\n\r\n/**\r\n * Find the group for an ICD code\r\n * @param {string} code - The ICD code\r\n * @param {Object} groupsMap - Map of groups\r\n * @returns {string} - Group description or empty string if not found\r\n */\r\nexport const findICDGroup = (code, groupsMap) => {\r\n  // Extract the base code (A00 from A00.1)\r\n  const baseCode = code.split('.')[0];\r\n  \r\n  // Find the group where the code falls between start and end\r\n  for (const groupKey in groupsMap) {\r\n    const group = groupsMap[groupKey];\r\n    if (baseCode >= group.start && baseCode <= group.end) {\r\n      return group.description;\r\n    }\r\n  }\r\n  \r\n  return '';\r\n};\r\n\r\n/**\r\n * Find the chapter for an OPS code\r\n * @param {string} code - The OPS code\r\n * @param {Object} chaptersMap - Map of chapters\r\n * @returns {string} - Chapter description or empty string if not found\r\n */\r\nexport const findOPSChapter = (code, chaptersMap) => {\r\n  // OPS codes start with the chapter number, e.g., \"1-20\" is in chapter \"1\"\r\n  const chapterId = code.split('-')[0];\r\n  \r\n  return chaptersMap[chapterId] ? chaptersMap[chapterId].description : '';\r\n};\r\n\r\n/**\r\n * Find the group for an OPS code\r\n * @param {string} code - The OPS code\r\n * @param {Object} groupsMap - Map of groups\r\n * @returns {string} - Group description or empty string if not found\r\n */\r\nexport const findOPSGroup = (code, groupsMap) => {\r\n  // Extract base code (1-20 from 1-202.00)\r\n  const parts = code.split('.');\r\n  let baseCode = parts[0];\r\n  \r\n  // If it's a detailed code like 1-202, we need the base group like 1-20\r\n  if (baseCode.match(/\\d-\\d{3}/)) {\r\n    baseCode = baseCode.substring(0, 4); // Get 1-20 from 1-202\r\n  }\r\n  \r\n  // Find the exact group or a parent group\r\n  if (groupsMap[baseCode]) {\r\n    return groupsMap[baseCode].description;\r\n  }\r\n  \r\n  // If not found, try to find a parent group\r\n  for (const groupKey in groupsMap) {\r\n    if (baseCode.startsWith(groupKey)) {\r\n      return groupsMap[groupKey].description;\r\n    }\r\n  }\r\n  \r\n  return '';\r\n};\r\n\r\n/**\r\n * Find the three-digit code for an OPS code\r\n * @param {string} code - The OPS code\r\n * @param {Object} dreistellerMap - Map of three-digit codes\r\n * @returns {string} - Three-digit code description or empty string if not found\r\n */\r\nexport const findOPSDreisteller = (code, dreistellerMap) => {\r\n  // Extract the three-digit part from codes like 1-202.00 -> 1-202\r\n  const dreistellerCode = code.split('.')[0];\r\n  \r\n  if (dreistellerMap[dreistellerCode]) {\r\n    return dreistellerMap[dreistellerCode].description;\r\n  }\r\n  \r\n  // If not found, it might be a parent code itself\r\n  if (dreistellerCode.match(/\\d-\\d{2}$/)) {\r\n    return dreistellerMap[dreistellerCode] ? dreistellerMap[dreistellerCode].description : '';\r\n  }\r\n  \r\n  return '';\r\n};\r\n\r\n/**\r\n * Erkennt, ob ein Code ein ICD oder OPS Code ist\r\n * @param {string} code - Der zu prüfende Code\r\n * @returns {string} - 'icd', 'ops' oder 'unknown'\r\n */\r\nexport const detectCodeType = (code) => {\r\n  // Normalisieren\r\n  const normalized = normalizeCode(code);\r\n  \r\n  // Wenn der Code mit einem Buchstaben beginnt, ist es ein ICD-Code\r\n  if (/^[A-Z]/.test(normalized)) {\r\n    return 'icd';\r\n  }\r\n  \r\n  // Wenn der Code mit einer Zahl beginnt, ist es ein OPS-Code\r\n  if (/^\\d/.test(normalized)) {\r\n    return 'ops';\r\n  }\r\n  \r\n  // Wenn nichts zutrifft, ist der Typ unbekannt\r\n  return 'unknown';\r\n};\r\n\r\n/**\r\n * Prüft, ob eine Liste von Codes gemischte Typen enthält\r\n * @param {Array<string>} codes - Liste der zu prüfenden Codes\r\n * @returns {Object} - Enthält Informationen über die erkannten Codetypen\r\n */\r\nexport const analyzeCodeTypes = (codes) => {\r\n  let hasICD = false;\r\n  let hasOPS = false;\r\n  let unknownCodes = [];\r\n  \r\n  for (const code of codes) {\r\n    const type = detectCodeType(code);\r\n    \r\n    if (type === 'icd') {\r\n      hasICD = true;\r\n    } else if (type === 'ops') {\r\n      hasOPS = true;\r\n    } else {\r\n      unknownCodes.push(code);\r\n    }\r\n  }\r\n  \r\n  return {\r\n    hasICD,\r\n    hasOPS,\r\n    unknownCodes,\r\n    isMixed: hasICD && hasOPS,\r\n    type: hasICD && !hasOPS ? 'icd' : !hasICD && hasOPS ? 'ops' : 'mixed'\r\n  };\r\n};\r\n\r\n/**\r\n * Findet den Dreisteller-Bereich für einen OPS-Code\r\n * @param {string} code - Der OPS-Code\r\n * @param {Object} dreistellerMap - Map der Dreisteller-Bereiche\r\n * @returns {Object} - Dreisteller-Informationen oder null wenn nicht gefunden\r\n */\r\nexport const findDreistellerRange = (code, dreistellerMap) => {\r\n  // Direkter Lookup für einzelne Dreisteller-Codes\r\n  if (dreistellerMap[code]) {\r\n    return dreistellerMap[code];\r\n  }\r\n  \r\n  // Extrahiere den Dreisteller-Teil (z.B. \"5-59\" aus \"5-590\")\r\n  const match = code.match(/^(\\d-\\d{2})/);\r\n  if (match) {\r\n    const dreistellerCode = match[1];\r\n    if (dreistellerMap[dreistellerCode]) {\r\n      return dreistellerMap[dreistellerCode];\r\n    }\r\n  }\r\n  \r\n  // Finde den passenden Bereich\r\n  for (const rangeKey in dreistellerMap) {\r\n    if (rangeKey.includes('-') && !dreistellerMap[rangeKey].isPartOfRange) {\r\n      const [startCode, endCode] = rangeKey.split('-');\r\n      if (code >= startCode && code <= endCode) {\r\n        return dreistellerMap[rangeKey];\r\n      }\r\n    }\r\n  }\r\n  \r\n  return null;\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}