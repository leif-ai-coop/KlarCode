{"ast":null,"code":"import { parseICDCodes, parseICDGroups, parseICDChapters, parseOPSCodes, parseOPSGroups, parseOPSChapters, parseOPSDreisteller } from '../utils/parser';\nimport { isValidICDFormat, isValidOPSFormat, normalizeCode, parseUserInput, isWildcardSearch, findWildcardMatches, findChildICDCodes, findChildOPSCodes, findICDChapter, findICDGroup, findOPSChapter, findOPSGroup, findOPSDreisteller, detectCodeType, formatOPSCode, findDreistellerRange } from '../utils/search';\n\n// Cache für geladene Daten\nconst dataCache = {\n  icd: {},\n  ops: {}\n};\n\n/**\r\n * Get the current year or fallback to 2025 if not available\r\n * @returns {string} - The current year\r\n */\nexport const getCurrentYear = () => {\n  const currentYear = new Date().getFullYear();\n  return currentYear >= 2025 && currentYear <= 2026 ? currentYear.toString() : '2025';\n};\n\n/**\r\n * Load all ICD-10 data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\nexport const loadICDData = async year => {\n  // Check if data is already cached\n  if (dataCache.icd[year]) {\n    return dataCache.icd[year];\n  }\n  try {\n    // Verschiedene Pfadvarianten testen\n    let baseUrl = `/data/${year}/icd10/`;\n\n    // Logging hinzufügen, um das Problem besser zu verstehen\n    console.log(`Attempting to load ICD data from: ${baseUrl}`);\n\n    // Load all required files\n    const codesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\n    if (!codesResponse.ok) {\n      console.error(`Failed to load ICD-10 codes: ${codesResponse.status}, trying alternative path...`);\n\n      // Alternative paths to try\n      baseUrl = `/src/data/${year}/icd10/`;\n      console.log(`Trying alternative path: ${baseUrl}`);\n      const altCodesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\n      if (!altCodesResponse.ok) {\n        console.error(`Failed to load ICD-10 codes from alternative path: ${altCodesResponse.status}`);\n        throw new Error(`Failed to load ICD-10 data for ${year}`);\n      }\n      console.log(\"Successfully loaded ICD data from alternative path!\");\n      const codes = parseICDCodes(await altCodesResponse.text());\n\n      // Load other files\n      const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\n      const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\n      if (!groupsResponse.ok || !chaptersResponse.ok) {\n        throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\n      }\n      const groups = parseICDGroups(await groupsResponse.text());\n      const chapters = parseICDChapters(await chaptersResponse.text());\n\n      // Cache the data\n      dataCache.icd[year] = {\n        codes,\n        groups,\n        chapters\n      };\n      return dataCache.icd[year];\n    }\n\n    // Ursprünglicher Code für den Fall, dass der erste Pfad funktioniert\n    console.log(\"Successfully loaded ICD data from original path!\");\n    const codesText = await codesResponse.text();\n    const codes = parseICDCodes(codesText);\n    const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\n    const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\n    if (!groupsResponse.ok || !chaptersResponse.ok) {\n      throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\n    }\n    const groupsText = await groupsResponse.text();\n    const chaptersText = await chaptersResponse.text();\n\n    // Parse the data\n    const groups = parseICDGroups(groupsText);\n    const chapters = parseICDChapters(chaptersText);\n\n    // Cache the data\n    dataCache.icd[year] = {\n      codes,\n      groups,\n      chapters\n    };\n\n    // Datenzusammenfassung ausgeben\n    console.log(`Loaded ${Object.keys(codes).length} ICD codes`);\n    console.log(`Sample codes:`, Object.keys(codes).slice(0, 5));\n    return dataCache.icd[year];\n  } catch (error) {\n    console.error(`Error loading ICD data for ${year}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Load all OPS data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\nexport const loadOPSData = async year => {\n  // Check if data is already cached\n  if (dataCache.ops[year]) {\n    return dataCache.ops[year];\n  }\n  try {\n    // Load all required files\n    const codesResponse = await fetch(`/data/${year}/ops/ops${year}syst_kodes.txt`);\n    const groupsResponse = await fetch(`/data/${year}/ops/ops${year}syst_gruppen.txt`);\n    const chaptersResponse = await fetch(`/data/${year}/ops/ops${year}syst_kapitel.txt`);\n    const dreistellerResponse = await fetch(`/data/${year}/ops/ops${year}syst_dreisteller.txt`);\n    if (!codesResponse.ok || !groupsResponse.ok || !chaptersResponse.ok || !dreistellerResponse.ok) {\n      throw new Error(`Failed to load OPS data for ${year}`);\n    }\n    const codesText = await codesResponse.text();\n    const groupsText = await groupsResponse.text();\n    const chaptersText = await chaptersResponse.text();\n    const dreistellerText = await dreistellerResponse.text();\n\n    // Parse the data\n    const codes = parseOPSCodes(codesText);\n    const groups = parseOPSGroups(groupsText);\n    const chapters = parseOPSChapters(chaptersText);\n    const dreisteller = parseOPSDreisteller(dreistellerText);\n\n    // Integriere alle Datensätze in eine umfassende Datenstruktur\n    const integratedCodes = {\n      ...codes\n    };\n\n    // Dreisteller hinzufügen, falls sie noch nicht in der Hauptcodeliste sind\n    for (const dreistellerCode in dreisteller) {\n      if (!integratedCodes[dreistellerCode]) {\n        integratedCodes[dreistellerCode] = {\n          kode: dreistellerCode,\n          beschreibung: dreisteller[dreistellerCode].description,\n          isNonTerminal: true,\n          // Markieren als übergeordneten Code\n          isDreisteller: true,\n          // Explizit als Dreisteller kennzeichnen\n          level: 3 // Dreisteller sind typischerweise Level 3\n        };\n      } else {\n        // Falls der Code bereits existiert, markiere ihn als Dreisteller\n        integratedCodes[dreistellerCode].isDreisteller = true;\n      }\n    }\n\n    // Cache the data with the integrated codes\n    dataCache.ops[year] = {\n      codes: integratedCodes,\n      groups,\n      chapters,\n      dreisteller\n    };\n    return dataCache.ops[year];\n  } catch (error) {\n    console.error(`Error loading OPS data for ${year}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Search for ICD-10 codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\nexport const searchICDCodes = async (input, year) => {\n  const results = [];\n  const errors = [];\n  try {\n    // Load or get cached data\n    const icdData = await loadICDData(year);\n    console.log(`ICD Data loaded, ${Object.keys(icdData.codes).length} codes available`);\n\n    // Parse user input\n    const {\n      codes,\n      duplicatesRemoved\n    } = parseUserInput(input);\n    console.log(`Parsed input \"${input}\" into codes for ICD search:`, codes);\n\n    // Process each code\n    for (const rawCode of codes) {\n      const code = normalizeCode(rawCode);\n\n      // Skip non-ICD codes\n      if (detectCodeType(code) !== 'icd') {\n        console.log(`Skipping non-ICD code: ${code}`);\n        continue;\n      }\n      console.log(`Processing ICD code \"${rawCode}\" (normalized: \"${code}\")`);\n\n      // Handle wildcard search\n      if (isWildcardSearch(code)) {\n        const matchedCodes = findWildcardMatches(code, icdData.codes);\n        if (matchedCodes.length === 0) {\n          errors.push(`Keine passenden ICD-Codes für Muster: ${rawCode}`);\n        } else {\n          matchedCodes.forEach(matchedCode => {\n            const codeData = icdData.codes[matchedCode];\n            results.push({\n              kode: matchedCode,\n              beschreibung: codeData.beschreibung,\n              gruppe: findICDGroup(matchedCode, icdData.groups),\n              kapitel: findICDChapter(matchedCode, icdData.codes, icdData.chapters),\n              isParent: true\n            });\n          });\n        }\n        continue;\n      }\n\n      // Validate code format\n      if (!isValidICDFormat(code)) {\n        errors.push(`Formatfehler: ICD-Codes müssen im Format A00, A00.1 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\n        continue;\n      }\n\n      // Check if code exists directly\n      if (icdData.codes[code]) {\n        const codeData = icdData.codes[code];\n\n        // Wenn es ein nicht-endstelliger Code ist oder explizit als solcher markiert ist\n        if (codeData.isNonTerminal || !code.includes('.')) {\n          // Suche nach zugehörigen endstelligen Codes\n          console.log(`${code} ist ein nicht-endstelliger Code, suche nach allen zugehörigen Codes...`);\n          const childCodes = findChildICDCodes(code, icdData.codes);\n          if (childCodes.length > 0) {\n            // Füge den übergeordneten Code hinzu\n            results.push({\n              kode: code,\n              beschreibung: codeData.beschreibung,\n              gruppe: findICDGroup(code, icdData.groups),\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters),\n              isParent: true // Markieren als übergeordneten Code\n            });\n\n            // Füge alle endstelligen Codes hinzu\n            childCodes.forEach(childCode => {\n              // Überspringe den übergeordneten Code selbst in der Kindliste\n              if (childCode === code) return;\n              results.push({\n                kode: childCode,\n                beschreibung: icdData.codes[childCode].beschreibung,\n                gruppe: findICDGroup(childCode, icdData.groups),\n                kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\n                parentCode: code // Referenz zum übergeordneten Code\n              });\n            });\n          } else {\n            // Wenn keine Kinder gefunden wurden, füge nur den Code selbst hinzu\n            results.push({\n              kode: code,\n              beschreibung: codeData.beschreibung,\n              gruppe: findICDGroup(code, icdData.groups),\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\n            });\n          }\n        } else {\n          // Für endstellige Codes füge einfach den Code selbst hinzu\n          results.push({\n            kode: code,\n            beschreibung: codeData.beschreibung,\n            gruppe: findICDGroup(code, icdData.groups),\n            kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\n          });\n        }\n      } else {\n        // Code nicht direkt gefunden, prüfe ob es ein übergeordneter Code ist\n        const childCodes = findChildICDCodes(code, icdData.codes);\n        if (childCodes.length > 0) {\n          console.log(`${code} wurde nicht direkt gefunden, aber ${childCodes.length} zugehörige Codes`);\n          // Füge alle gefundenen Kinder hinzu\n          childCodes.forEach(childCode => {\n            results.push({\n              kode: childCode,\n              beschreibung: icdData.codes[childCode].beschreibung,\n              gruppe: findICDGroup(childCode, icdData.groups),\n              kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\n              fromParent: code // Markieren, aus welchem übergeordneten Code dieser stammt\n            });\n          });\n        } else {\n          errors.push(`ICD-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n        }\n      }\n    }\n    console.log(`ICD search complete, found ${results.length} results`);\n    return {\n      results,\n      duplicatesRemoved,\n      errors\n    };\n  } catch (error) {\n    console.error('Error searching ICD codes:', error);\n    errors.push(`Fehler bei der Suche: ${error.message}`);\n    return {\n      results,\n      duplicatesRemoved: 0,\n      errors\n    };\n  }\n};\n\n/**\r\n * Search for OPS codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @param {boolean} showChildCodes - Whether to include child codes in results (default: false)\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\nexport const searchOPSCodes = async (input, year, showChildCodes = false) => {\n  const results = [];\n  const errors = [];\n  try {\n    // Load or get cached data\n    const opsData = await loadOPSData(year);\n    console.log(`OPS Data loaded, ${Object.keys(opsData.codes).length} codes available`);\n\n    // Parse user input\n    const {\n      codes,\n      duplicatesRemoved\n    } = parseUserInput(input);\n    console.log(`Parsed input \"${input}\" into codes for OPS search:`, codes);\n\n    // Process each code\n    for (const rawCode of codes) {\n      const code = normalizeCode(rawCode);\n\n      // Skip non-OPS codes\n      if (detectCodeType(code) !== 'ops') {\n        console.log(`Skipping non-OPS code: ${code}`);\n        continue;\n      }\n\n      // Formatieren des OPS-Codes\n      const formattedCode = formatOPSCode(code);\n      console.log(`Processing OPS code \"${rawCode}\" (normalized: \"${code}\", formatted: \"${formattedCode}\")`);\n\n      // Handle wildcard search\n      if (isWildcardSearch(formattedCode)) {\n        const matchedCodes = findWildcardMatches(formattedCode, opsData.codes);\n        if (matchedCodes.length === 0) {\n          errors.push(`Keine passenden OPS-Codes für Muster: ${rawCode}`);\n        } else {\n          matchedCodes.forEach(matchedCode => {\n            var _findDreistellerRange;\n            const codeData = opsData.codes[matchedCode];\n            results.push({\n              kode: matchedCode,\n              beschreibung: codeData.beschreibung,\n              gruppe: findOPSGroup(matchedCode, opsData.groups),\n              kapitel: findOPSChapter(matchedCode, opsData.chapters),\n              dreisteller: ((_findDreistellerRange = findDreistellerRange(formattedCode, opsData.dreisteller)) === null || _findDreistellerRange === void 0 ? void 0 : _findDreistellerRange.description) || '',\n              isParent: codeData.isNonTerminal\n            });\n          });\n        }\n        continue;\n      }\n\n      // Validate code format\n      if (!isValidOPSFormat(formattedCode)) {\n        errors.push(`Formatfehler: OPS-Codes müssen im Format 1-20, 1-202.00 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\n        continue;\n      }\n\n      // Check if code exists directly\n      if (opsData.codes[formattedCode]) {\n        const codeData = opsData.codes[formattedCode];\n\n        // Finde den Dreisteller-Bereich\n        const dreistellerInfo = findDreistellerRange(formattedCode, opsData.dreisteller);\n\n        // Füge den Hauptcode immer zu den Ergebnissen hinzu\n        results.push({\n          kode: formattedCode,\n          beschreibung: codeData.beschreibung,\n          gruppe: findOPSGroup(formattedCode, opsData.groups),\n          kapitel: findOPSChapter(formattedCode, opsData.chapters),\n          dreisteller: dreistellerInfo ? dreistellerInfo.description : '',\n          isParent: codeData.isNonTerminal\n        });\n\n        // Wenn es ein übergeordneter Code ist und showChildCodes aktiviert ist,\n        // finde und füge alle Kindcodes hinzu\n        if (showChildCodes && codeData.isNonTerminal) {\n          console.log(`${formattedCode} ist ein nicht-endstelliger OPS-Code, suche nach allen zugehörigen Codes...`);\n          const childCodes = findChildOPSCodes(formattedCode, opsData.codes);\n          if (childCodes.length > 0) {\n            // Füge alle endstelligen Codes hinzu\n            childCodes.forEach(childCode => {\n              // Überspringe den übergeordneten Code selbst in der Kindliste\n              if (childCode === formattedCode) return;\n              const childDreistellerInfo = findDreistellerRange(childCode, opsData.dreisteller);\n              results.push({\n                kode: childCode,\n                beschreibung: opsData.codes[childCode].beschreibung,\n                gruppe: findOPSGroup(childCode, opsData.groups),\n                kapitel: findOPSChapter(childCode, opsData.chapters),\n                dreisteller: childDreistellerInfo ? childDreistellerInfo.description : '',\n                parentCode: formattedCode // Referenz zum übergeordneten Code\n              });\n            });\n          }\n        }\n      } else {\n        // Wenn der Code nicht direkt gefunden wurde, prüfe auf Dreisteller\n        const dreistellerMatch = formattedCode.match(/^(\\d-\\d{2})$/);\n        if (dreistellerMatch) {\n          const dreistellerCode = dreistellerMatch[1];\n          const dreistellerInfo = findDreistellerRange(dreistellerCode, opsData.dreisteller);\n          if (dreistellerInfo) {\n            // Füge den Dreisteller selbst hinzu\n            results.push({\n              kode: dreistellerCode,\n              beschreibung: dreistellerInfo.description,\n              gruppe: dreistellerInfo.description,\n              kapitel: findOPSChapter(dreistellerCode, opsData.chapters),\n              dreisteller: dreistellerInfo.description,\n              isParent: true\n            });\n\n            // Finde alle Kindcodes dieses Dreistellercodes, aber nur wenn showChildCodes aktiviert ist\n            if (showChildCodes) {\n              const childPattern = new RegExp(`^${dreistellerCode}\\\\d`);\n              const childCodes = Object.keys(opsData.codes).filter(code => childPattern.test(code));\n              if (childCodes.length > 0) {\n                childCodes.forEach(childCode => {\n                  const childData = opsData.codes[childCode];\n                  results.push({\n                    kode: childCode,\n                    beschreibung: childData.beschreibung,\n                    gruppe: dreistellerInfo.description,\n                    kapitel: findOPSChapter(childCode, opsData.chapters),\n                    dreisteller: dreistellerInfo.description,\n                    parentCode: dreistellerCode\n                  });\n                });\n              }\n            }\n          } else {\n            errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n          }\n        } else {\n          errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n        }\n      }\n    }\n    console.log(`OPS search complete, found ${results.length} results`);\n    return {\n      results,\n      duplicatesRemoved,\n      errors\n    };\n  } catch (error) {\n    console.error('Error searching OPS codes:', error);\n    errors.push(`Fehler bei der Suche: ${error.message}`);\n    return {\n      results,\n      duplicatesRemoved: 0,\n      errors\n    };\n  }\n};","map":{"version":3,"names":["parseICDCodes","parseICDGroups","parseICDChapters","parseOPSCodes","parseOPSGroups","parseOPSChapters","parseOPSDreisteller","isValidICDFormat","isValidOPSFormat","normalizeCode","parseUserInput","isWildcardSearch","findWildcardMatches","findChildICDCodes","findChildOPSCodes","findICDChapter","findICDGroup","findOPSChapter","findOPSGroup","findOPSDreisteller","detectCodeType","formatOPSCode","findDreistellerRange","dataCache","icd","ops","getCurrentYear","currentYear","Date","getFullYear","toString","loadICDData","year","baseUrl","console","log","codesResponse","fetch","ok","error","status","altCodesResponse","Error","codes","text","groupsResponse","chaptersResponse","groups","chapters","codesText","groupsText","chaptersText","Object","keys","length","slice","loadOPSData","dreistellerResponse","dreistellerText","dreisteller","integratedCodes","dreistellerCode","kode","beschreibung","description","isNonTerminal","isDreisteller","level","searchICDCodes","input","results","errors","icdData","duplicatesRemoved","rawCode","code","matchedCodes","push","forEach","matchedCode","codeData","gruppe","kapitel","isParent","includes","childCodes","childCode","parentCode","fromParent","message","searchOPSCodes","showChildCodes","opsData","formattedCode","_findDreistellerRange","dreistellerInfo","childDreistellerInfo","dreistellerMatch","match","childPattern","RegExp","filter","test","childData"],"sources":["C:/Code/KlarCode/src/services/dataService.js"],"sourcesContent":["import { \r\n  parseICDCodes, \r\n  parseICDGroups, \r\n  parseICDChapters,\r\n  parseOPSCodes,\r\n  parseOPSGroups,\r\n  parseOPSChapters,\r\n  parseOPSDreisteller\r\n} from '../utils/parser';\r\n\r\nimport {\r\n  isValidICDFormat,\r\n  isValidOPSFormat,\r\n  normalizeCode,\r\n  parseUserInput,\r\n  isWildcardSearch,\r\n  findWildcardMatches,\r\n  findChildICDCodes,\r\n  findChildOPSCodes,\r\n  findICDChapter,\r\n  findICDGroup,\r\n  findOPSChapter,\r\n  findOPSGroup,\r\n  findOPSDreisteller,\r\n  detectCodeType,\r\n  formatOPSCode,\r\n  findDreistellerRange\r\n} from '../utils/search';\r\n\r\n// Cache für geladene Daten\r\nconst dataCache = {\r\n  icd: {},\r\n  ops: {}\r\n};\r\n\r\n/**\r\n * Get the current year or fallback to 2025 if not available\r\n * @returns {string} - The current year\r\n */\r\nexport const getCurrentYear = () => {\r\n  const currentYear = new Date().getFullYear();\r\n  return currentYear >= 2025 && currentYear <= 2026 ? currentYear.toString() : '2025';\r\n};\r\n\r\n/**\r\n * Load all ICD-10 data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\r\nexport const loadICDData = async (year) => {\r\n  // Check if data is already cached\r\n  if (dataCache.icd[year]) {\r\n    return dataCache.icd[year];\r\n  }\r\n  \r\n  try {\r\n    // Verschiedene Pfadvarianten testen\r\n    let baseUrl = `/data/${year}/icd10/`;\r\n    \r\n    // Logging hinzufügen, um das Problem besser zu verstehen\r\n    console.log(`Attempting to load ICD data from: ${baseUrl}`);\r\n    \r\n    // Load all required files\r\n    const codesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\r\n    \r\n    if (!codesResponse.ok) {\r\n      console.error(`Failed to load ICD-10 codes: ${codesResponse.status}, trying alternative path...`);\r\n      \r\n      // Alternative paths to try\r\n      baseUrl = `/src/data/${year}/icd10/`;\r\n      console.log(`Trying alternative path: ${baseUrl}`);\r\n      \r\n      const altCodesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\r\n      \r\n      if (!altCodesResponse.ok) {\r\n        console.error(`Failed to load ICD-10 codes from alternative path: ${altCodesResponse.status}`);\r\n        throw new Error(`Failed to load ICD-10 data for ${year}`);\r\n      }\r\n      \r\n      console.log(\"Successfully loaded ICD data from alternative path!\");\r\n      const codes = parseICDCodes(await altCodesResponse.text());\r\n      \r\n      // Load other files\r\n      const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\r\n      const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\r\n      \r\n      if (!groupsResponse.ok || !chaptersResponse.ok) {\r\n        throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\r\n      }\r\n      \r\n      const groups = parseICDGroups(await groupsResponse.text());\r\n      const chapters = parseICDChapters(await chaptersResponse.text());\r\n      \r\n      // Cache the data\r\n      dataCache.icd[year] = { codes, groups, chapters };\r\n      \r\n      return dataCache.icd[year];\r\n    }\r\n    \r\n    // Ursprünglicher Code für den Fall, dass der erste Pfad funktioniert\r\n    console.log(\"Successfully loaded ICD data from original path!\");\r\n    const codesText = await codesResponse.text();\r\n    const codes = parseICDCodes(codesText);\r\n    \r\n    const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\r\n    const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\r\n    \r\n    if (!groupsResponse.ok || !chaptersResponse.ok) {\r\n      throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\r\n    }\r\n    \r\n    const groupsText = await groupsResponse.text();\r\n    const chaptersText = await chaptersResponse.text();\r\n    \r\n    // Parse the data\r\n    const groups = parseICDGroups(groupsText);\r\n    const chapters = parseICDChapters(chaptersText);\r\n    \r\n    // Cache the data\r\n    dataCache.icd[year] = { codes, groups, chapters };\r\n    \r\n    // Datenzusammenfassung ausgeben\r\n    console.log(`Loaded ${Object.keys(codes).length} ICD codes`);\r\n    console.log(`Sample codes:`, Object.keys(codes).slice(0, 5));\r\n    \r\n    return dataCache.icd[year];\r\n  } catch (error) {\r\n    console.error(`Error loading ICD data for ${year}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Load all OPS data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\r\nexport const loadOPSData = async (year) => {\r\n  // Check if data is already cached\r\n  if (dataCache.ops[year]) {\r\n    return dataCache.ops[year];\r\n  }\r\n  \r\n  try {\r\n    // Load all required files\r\n    const codesResponse = await fetch(`/data/${year}/ops/ops${year}syst_kodes.txt`);\r\n    const groupsResponse = await fetch(`/data/${year}/ops/ops${year}syst_gruppen.txt`);\r\n    const chaptersResponse = await fetch(`/data/${year}/ops/ops${year}syst_kapitel.txt`);\r\n    const dreistellerResponse = await fetch(`/data/${year}/ops/ops${year}syst_dreisteller.txt`);\r\n    \r\n    if (!codesResponse.ok || !groupsResponse.ok || !chaptersResponse.ok || !dreistellerResponse.ok) {\r\n      throw new Error(`Failed to load OPS data for ${year}`);\r\n    }\r\n    \r\n    const codesText = await codesResponse.text();\r\n    const groupsText = await groupsResponse.text();\r\n    const chaptersText = await chaptersResponse.text();\r\n    const dreistellerText = await dreistellerResponse.text();\r\n    \r\n    // Parse the data\r\n    const codes = parseOPSCodes(codesText);\r\n    const groups = parseOPSGroups(groupsText);\r\n    const chapters = parseOPSChapters(chaptersText);\r\n    const dreisteller = parseOPSDreisteller(dreistellerText);\r\n    \r\n    // Integriere alle Datensätze in eine umfassende Datenstruktur\r\n    const integratedCodes = { ...codes };\r\n    \r\n    // Dreisteller hinzufügen, falls sie noch nicht in der Hauptcodeliste sind\r\n    for (const dreistellerCode in dreisteller) {\r\n      if (!integratedCodes[dreistellerCode]) {\r\n        integratedCodes[dreistellerCode] = {\r\n          kode: dreistellerCode,\r\n          beschreibung: dreisteller[dreistellerCode].description,\r\n          isNonTerminal: true, // Markieren als übergeordneten Code\r\n          isDreisteller: true, // Explizit als Dreisteller kennzeichnen\r\n          level: 3 // Dreisteller sind typischerweise Level 3\r\n        };\r\n      } else {\r\n        // Falls der Code bereits existiert, markiere ihn als Dreisteller\r\n        integratedCodes[dreistellerCode].isDreisteller = true;\r\n      }\r\n    }\r\n    \r\n    // Cache the data with the integrated codes\r\n    dataCache.ops[year] = { \r\n      codes: integratedCodes,\r\n      groups, \r\n      chapters, \r\n      dreisteller \r\n    };\r\n    \r\n    return dataCache.ops[year];\r\n  } catch (error) {\r\n    console.error(`Error loading OPS data for ${year}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Search for ICD-10 codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\r\nexport const searchICDCodes = async (input, year) => {\r\n  const results = [];\r\n  const errors = [];\r\n  \r\n  try {\r\n    // Load or get cached data\r\n    const icdData = await loadICDData(year);\r\n    console.log(`ICD Data loaded, ${Object.keys(icdData.codes).length} codes available`);\r\n    \r\n    // Parse user input\r\n    const { codes, duplicatesRemoved } = parseUserInput(input);\r\n    console.log(`Parsed input \"${input}\" into codes for ICD search:`, codes);\r\n    \r\n    // Process each code\r\n    for (const rawCode of codes) {\r\n      const code = normalizeCode(rawCode);\r\n      \r\n      // Skip non-ICD codes\r\n      if (detectCodeType(code) !== 'icd') {\r\n        console.log(`Skipping non-ICD code: ${code}`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`Processing ICD code \"${rawCode}\" (normalized: \"${code}\")`);\r\n      \r\n      // Handle wildcard search\r\n      if (isWildcardSearch(code)) {\r\n        const matchedCodes = findWildcardMatches(code, icdData.codes);\r\n        \r\n        if (matchedCodes.length === 0) {\r\n          errors.push(`Keine passenden ICD-Codes für Muster: ${rawCode}`);\r\n        } else {\r\n          matchedCodes.forEach(matchedCode => {\r\n            const codeData = icdData.codes[matchedCode];\r\n            results.push({\r\n              kode: matchedCode,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findICDGroup(matchedCode, icdData.groups),\r\n              kapitel: findICDChapter(matchedCode, icdData.codes, icdData.chapters),\r\n              isParent: true\r\n            });\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n      \r\n      // Validate code format\r\n      if (!isValidICDFormat(code)) {\r\n        errors.push(`Formatfehler: ICD-Codes müssen im Format A00, A00.1 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\r\n        continue;\r\n      }\r\n      \r\n      // Check if code exists directly\r\n      if (icdData.codes[code]) {\r\n        const codeData = icdData.codes[code];\r\n        \r\n        // Wenn es ein nicht-endstelliger Code ist oder explizit als solcher markiert ist\r\n        if (codeData.isNonTerminal || !code.includes('.')) {\r\n          // Suche nach zugehörigen endstelligen Codes\r\n          console.log(`${code} ist ein nicht-endstelliger Code, suche nach allen zugehörigen Codes...`);\r\n          const childCodes = findChildICDCodes(code, icdData.codes);\r\n          \r\n          if (childCodes.length > 0) {\r\n            // Füge den übergeordneten Code hinzu\r\n            results.push({\r\n              kode: code,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findICDGroup(code, icdData.groups),\r\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters),\r\n              isParent: true // Markieren als übergeordneten Code\r\n            });\r\n            \r\n            // Füge alle endstelligen Codes hinzu\r\n            childCodes.forEach(childCode => {\r\n              // Überspringe den übergeordneten Code selbst in der Kindliste\r\n              if (childCode === code) return;\r\n              \r\n              results.push({\r\n                kode: childCode,\r\n                beschreibung: icdData.codes[childCode].beschreibung,\r\n                gruppe: findICDGroup(childCode, icdData.groups),\r\n                kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\r\n                parentCode: code // Referenz zum übergeordneten Code\r\n              });\r\n            });\r\n          } else {\r\n            // Wenn keine Kinder gefunden wurden, füge nur den Code selbst hinzu\r\n            results.push({\r\n              kode: code,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findICDGroup(code, icdData.groups),\r\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\r\n            });\r\n          }\r\n        } else {\r\n          // Für endstellige Codes füge einfach den Code selbst hinzu\r\n          results.push({\r\n            kode: code,\r\n            beschreibung: codeData.beschreibung,\r\n            gruppe: findICDGroup(code, icdData.groups),\r\n            kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\r\n          });\r\n        }\r\n      } else {\r\n        // Code nicht direkt gefunden, prüfe ob es ein übergeordneter Code ist\r\n        const childCodes = findChildICDCodes(code, icdData.codes);\r\n        \r\n        if (childCodes.length > 0) {\r\n          console.log(`${code} wurde nicht direkt gefunden, aber ${childCodes.length} zugehörige Codes`);\r\n          // Füge alle gefundenen Kinder hinzu\r\n          childCodes.forEach(childCode => {\r\n            results.push({\r\n              kode: childCode,\r\n              beschreibung: icdData.codes[childCode].beschreibung,\r\n              gruppe: findICDGroup(childCode, icdData.groups),\r\n              kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\r\n              fromParent: code // Markieren, aus welchem übergeordneten Code dieser stammt\r\n            });\r\n          });\r\n        } else {\r\n          errors.push(`ICD-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`ICD search complete, found ${results.length} results`);\r\n    return {\r\n      results,\r\n      duplicatesRemoved,\r\n      errors\r\n    };\r\n  } catch (error) {\r\n    console.error('Error searching ICD codes:', error);\r\n    errors.push(`Fehler bei der Suche: ${error.message}`);\r\n    return { results, duplicatesRemoved: 0, errors };\r\n  }\r\n};\r\n\r\n/**\r\n * Search for OPS codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @param {boolean} showChildCodes - Whether to include child codes in results (default: false)\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\r\nexport const searchOPSCodes = async (input, year, showChildCodes = false) => {\r\n  const results = [];\r\n  const errors = [];\r\n  \r\n  try {\r\n    // Load or get cached data\r\n    const opsData = await loadOPSData(year);\r\n    console.log(`OPS Data loaded, ${Object.keys(opsData.codes).length} codes available`);\r\n    \r\n    // Parse user input\r\n    const { codes, duplicatesRemoved } = parseUserInput(input);\r\n    console.log(`Parsed input \"${input}\" into codes for OPS search:`, codes);\r\n    \r\n    // Process each code\r\n    for (const rawCode of codes) {\r\n      const code = normalizeCode(rawCode);\r\n      \r\n      // Skip non-OPS codes\r\n      if (detectCodeType(code) !== 'ops') {\r\n        console.log(`Skipping non-OPS code: ${code}`);\r\n        continue;\r\n      }\r\n      \r\n      // Formatieren des OPS-Codes\r\n      const formattedCode = formatOPSCode(code);\r\n      \r\n      console.log(`Processing OPS code \"${rawCode}\" (normalized: \"${code}\", formatted: \"${formattedCode}\")`);\r\n      \r\n      // Handle wildcard search\r\n      if (isWildcardSearch(formattedCode)) {\r\n        const matchedCodes = findWildcardMatches(formattedCode, opsData.codes);\r\n        \r\n        if (matchedCodes.length === 0) {\r\n          errors.push(`Keine passenden OPS-Codes für Muster: ${rawCode}`);\r\n        } else {\r\n          matchedCodes.forEach(matchedCode => {\r\n            const codeData = opsData.codes[matchedCode];\r\n            results.push({\r\n              kode: matchedCode,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findOPSGroup(matchedCode, opsData.groups),\r\n              kapitel: findOPSChapter(matchedCode, opsData.chapters),\r\n              dreisteller: findDreistellerRange(formattedCode, opsData.dreisteller)?.description || '',\r\n              isParent: codeData.isNonTerminal\r\n            });\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n      \r\n      // Validate code format\r\n      if (!isValidOPSFormat(formattedCode)) {\r\n        errors.push(`Formatfehler: OPS-Codes müssen im Format 1-20, 1-202.00 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\r\n        continue;\r\n      }\r\n      \r\n      // Check if code exists directly\r\n      if (opsData.codes[formattedCode]) {\r\n        const codeData = opsData.codes[formattedCode];\r\n        \r\n        // Finde den Dreisteller-Bereich\r\n        const dreistellerInfo = findDreistellerRange(formattedCode, opsData.dreisteller);\r\n        \r\n        // Füge den Hauptcode immer zu den Ergebnissen hinzu\r\n        results.push({\r\n          kode: formattedCode,\r\n          beschreibung: codeData.beschreibung,\r\n          gruppe: findOPSGroup(formattedCode, opsData.groups),\r\n          kapitel: findOPSChapter(formattedCode, opsData.chapters),\r\n          dreisteller: dreistellerInfo ? dreistellerInfo.description : '',\r\n          isParent: codeData.isNonTerminal\r\n        });\r\n        \r\n        // Wenn es ein übergeordneter Code ist und showChildCodes aktiviert ist,\r\n        // finde und füge alle Kindcodes hinzu\r\n        if (showChildCodes && codeData.isNonTerminal) {\r\n          console.log(`${formattedCode} ist ein nicht-endstelliger OPS-Code, suche nach allen zugehörigen Codes...`);\r\n          const childCodes = findChildOPSCodes(formattedCode, opsData.codes);\r\n          \r\n          if (childCodes.length > 0) {\r\n            // Füge alle endstelligen Codes hinzu\r\n            childCodes.forEach(childCode => {\r\n              // Überspringe den übergeordneten Code selbst in der Kindliste\r\n              if (childCode === formattedCode) return;\r\n              \r\n              const childDreistellerInfo = findDreistellerRange(childCode, opsData.dreisteller);\r\n              \r\n              results.push({\r\n                kode: childCode,\r\n                beschreibung: opsData.codes[childCode].beschreibung,\r\n                gruppe: findOPSGroup(childCode, opsData.groups),\r\n                kapitel: findOPSChapter(childCode, opsData.chapters),\r\n                dreisteller: childDreistellerInfo ? childDreistellerInfo.description : '',\r\n                parentCode: formattedCode // Referenz zum übergeordneten Code\r\n              });\r\n            });\r\n          }\r\n        }\r\n      } else {\r\n        // Wenn der Code nicht direkt gefunden wurde, prüfe auf Dreisteller\r\n        const dreistellerMatch = formattedCode.match(/^(\\d-\\d{2})$/);\r\n        \r\n        if (dreistellerMatch) {\r\n          const dreistellerCode = dreistellerMatch[1];\r\n          const dreistellerInfo = findDreistellerRange(dreistellerCode, opsData.dreisteller);\r\n          \r\n          if (dreistellerInfo) {\r\n            // Füge den Dreisteller selbst hinzu\r\n            results.push({\r\n              kode: dreistellerCode,\r\n              beschreibung: dreistellerInfo.description,\r\n              gruppe: dreistellerInfo.description,\r\n              kapitel: findOPSChapter(dreistellerCode, opsData.chapters),\r\n              dreisteller: dreistellerInfo.description,\r\n              isParent: true\r\n            });\r\n            \r\n            // Finde alle Kindcodes dieses Dreistellercodes, aber nur wenn showChildCodes aktiviert ist\r\n            if (showChildCodes) {\r\n              const childPattern = new RegExp(`^${dreistellerCode}\\\\d`);\r\n              const childCodes = Object.keys(opsData.codes).filter(code => \r\n                childPattern.test(code)\r\n              );\r\n              \r\n              if (childCodes.length > 0) {\r\n                childCodes.forEach(childCode => {\r\n                  const childData = opsData.codes[childCode];\r\n                  results.push({\r\n                    kode: childCode,\r\n                    beschreibung: childData.beschreibung,\r\n                    gruppe: dreistellerInfo.description,\r\n                    kapitel: findOPSChapter(childCode, opsData.chapters),\r\n                    dreisteller: dreistellerInfo.description,\r\n                    parentCode: dreistellerCode\r\n                  });\r\n                });\r\n              }\r\n            }\r\n          } else {\r\n            errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n          }\r\n        } else {\r\n          errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`OPS search complete, found ${results.length} results`);\r\n    return {\r\n      results,\r\n      duplicatesRemoved,\r\n      errors\r\n    };\r\n  } catch (error) {\r\n    console.error('Error searching OPS codes:', error);\r\n    errors.push(`Fehler bei der Suche: ${error.message}`);\r\n    return { results, duplicatesRemoved: 0, errors };\r\n  }\r\n}; "],"mappings":"AAAA,SACEA,aAAa,EACbC,cAAc,EACdC,gBAAgB,EAChBC,aAAa,EACbC,cAAc,EACdC,gBAAgB,EAChBC,mBAAmB,QACd,iBAAiB;AAExB,SACEC,gBAAgB,EAChBC,gBAAgB,EAChBC,aAAa,EACbC,cAAc,EACdC,gBAAgB,EAChBC,mBAAmB,EACnBC,iBAAiB,EACjBC,iBAAiB,EACjBC,cAAc,EACdC,YAAY,EACZC,cAAc,EACdC,YAAY,EACZC,kBAAkB,EAClBC,cAAc,EACdC,aAAa,EACbC,oBAAoB,QACf,iBAAiB;;AAExB;AACA,MAAMC,SAAS,GAAG;EAChBC,GAAG,EAAE,CAAC,CAAC;EACPC,GAAG,EAAE,CAAC;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAGA,CAAA,KAAM;EAClC,MAAMC,WAAW,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAC5C,OAAOF,WAAW,IAAI,IAAI,IAAIA,WAAW,IAAI,IAAI,GAAGA,WAAW,CAACG,QAAQ,CAAC,CAAC,GAAG,MAAM;AACrF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAG,MAAOC,IAAI,IAAK;EACzC;EACA,IAAIT,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC,EAAE;IACvB,OAAOT,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC;EAC5B;EAEA,IAAI;IACF;IACA,IAAIC,OAAO,GAAG,SAASD,IAAI,SAAS;;IAEpC;IACAE,OAAO,CAACC,GAAG,CAAC,qCAAqCF,OAAO,EAAE,CAAC;;IAE3D;IACA,MAAMG,aAAa,GAAG,MAAMC,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,gBAAgB,CAAC;IAE3E,IAAI,CAACI,aAAa,CAACE,EAAE,EAAE;MACrBJ,OAAO,CAACK,KAAK,CAAC,gCAAgCH,aAAa,CAACI,MAAM,8BAA8B,CAAC;;MAEjG;MACAP,OAAO,GAAG,aAAaD,IAAI,SAAS;MACpCE,OAAO,CAACC,GAAG,CAAC,4BAA4BF,OAAO,EAAE,CAAC;MAElD,MAAMQ,gBAAgB,GAAG,MAAMJ,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,gBAAgB,CAAC;MAE9E,IAAI,CAACS,gBAAgB,CAACH,EAAE,EAAE;QACxBJ,OAAO,CAACK,KAAK,CAAC,sDAAsDE,gBAAgB,CAACD,MAAM,EAAE,CAAC;QAC9F,MAAM,IAAIE,KAAK,CAAC,kCAAkCV,IAAI,EAAE,CAAC;MAC3D;MAEAE,OAAO,CAACC,GAAG,CAAC,qDAAqD,CAAC;MAClE,MAAMQ,KAAK,GAAG3C,aAAa,CAAC,MAAMyC,gBAAgB,CAACG,IAAI,CAAC,CAAC,CAAC;;MAE1D;MACA,MAAMC,cAAc,GAAG,MAAMR,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;MAC9E,MAAMc,gBAAgB,GAAG,MAAMT,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;MAEhF,IAAI,CAACa,cAAc,CAACP,EAAE,IAAI,CAACQ,gBAAgB,CAACR,EAAE,EAAE;QAC9C,MAAM,IAAII,KAAK,CAAC,gDAAgDV,IAAI,EAAE,CAAC;MACzE;MAEA,MAAMe,MAAM,GAAG9C,cAAc,CAAC,MAAM4C,cAAc,CAACD,IAAI,CAAC,CAAC,CAAC;MAC1D,MAAMI,QAAQ,GAAG9C,gBAAgB,CAAC,MAAM4C,gBAAgB,CAACF,IAAI,CAAC,CAAC,CAAC;;MAEhE;MACArB,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC,GAAG;QAAEW,KAAK;QAAEI,MAAM;QAAEC;MAAS,CAAC;MAEjD,OAAOzB,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC;IAC5B;;IAEA;IACAE,OAAO,CAACC,GAAG,CAAC,kDAAkD,CAAC;IAC/D,MAAMc,SAAS,GAAG,MAAMb,aAAa,CAACQ,IAAI,CAAC,CAAC;IAC5C,MAAMD,KAAK,GAAG3C,aAAa,CAACiD,SAAS,CAAC;IAEtC,MAAMJ,cAAc,GAAG,MAAMR,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;IAC9E,MAAMc,gBAAgB,GAAG,MAAMT,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;IAEhF,IAAI,CAACa,cAAc,CAACP,EAAE,IAAI,CAACQ,gBAAgB,CAACR,EAAE,EAAE;MAC9C,MAAM,IAAII,KAAK,CAAC,gDAAgDV,IAAI,EAAE,CAAC;IACzE;IAEA,MAAMkB,UAAU,GAAG,MAAML,cAAc,CAACD,IAAI,CAAC,CAAC;IAC9C,MAAMO,YAAY,GAAG,MAAML,gBAAgB,CAACF,IAAI,CAAC,CAAC;;IAElD;IACA,MAAMG,MAAM,GAAG9C,cAAc,CAACiD,UAAU,CAAC;IACzC,MAAMF,QAAQ,GAAG9C,gBAAgB,CAACiD,YAAY,CAAC;;IAE/C;IACA5B,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC,GAAG;MAAEW,KAAK;MAAEI,MAAM;MAAEC;IAAS,CAAC;;IAEjD;IACAd,OAAO,CAACC,GAAG,CAAC,UAAUiB,MAAM,CAACC,IAAI,CAACV,KAAK,CAAC,CAACW,MAAM,YAAY,CAAC;IAC5DpB,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEiB,MAAM,CAACC,IAAI,CAACV,KAAK,CAAC,CAACY,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAE5D,OAAOhC,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC;EAC5B,CAAC,CAAC,OAAOO,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,8BAA8BP,IAAI,GAAG,EAAEO,KAAK,CAAC;IAC3D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMiB,WAAW,GAAG,MAAOxB,IAAI,IAAK;EACzC;EACA,IAAIT,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC,EAAE;IACvB,OAAOT,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC;EAC5B;EAEA,IAAI;IACF;IACA,MAAMI,aAAa,GAAG,MAAMC,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,gBAAgB,CAAC;IAC/E,MAAMa,cAAc,GAAG,MAAMR,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,kBAAkB,CAAC;IAClF,MAAMc,gBAAgB,GAAG,MAAMT,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,kBAAkB,CAAC;IACpF,MAAMyB,mBAAmB,GAAG,MAAMpB,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,sBAAsB,CAAC;IAE3F,IAAI,CAACI,aAAa,CAACE,EAAE,IAAI,CAACO,cAAc,CAACP,EAAE,IAAI,CAACQ,gBAAgB,CAACR,EAAE,IAAI,CAACmB,mBAAmB,CAACnB,EAAE,EAAE;MAC9F,MAAM,IAAII,KAAK,CAAC,+BAA+BV,IAAI,EAAE,CAAC;IACxD;IAEA,MAAMiB,SAAS,GAAG,MAAMb,aAAa,CAACQ,IAAI,CAAC,CAAC;IAC5C,MAAMM,UAAU,GAAG,MAAML,cAAc,CAACD,IAAI,CAAC,CAAC;IAC9C,MAAMO,YAAY,GAAG,MAAML,gBAAgB,CAACF,IAAI,CAAC,CAAC;IAClD,MAAMc,eAAe,GAAG,MAAMD,mBAAmB,CAACb,IAAI,CAAC,CAAC;;IAExD;IACA,MAAMD,KAAK,GAAGxC,aAAa,CAAC8C,SAAS,CAAC;IACtC,MAAMF,MAAM,GAAG3C,cAAc,CAAC8C,UAAU,CAAC;IACzC,MAAMF,QAAQ,GAAG3C,gBAAgB,CAAC8C,YAAY,CAAC;IAC/C,MAAMQ,WAAW,GAAGrD,mBAAmB,CAACoD,eAAe,CAAC;;IAExD;IACA,MAAME,eAAe,GAAG;MAAE,GAAGjB;IAAM,CAAC;;IAEpC;IACA,KAAK,MAAMkB,eAAe,IAAIF,WAAW,EAAE;MACzC,IAAI,CAACC,eAAe,CAACC,eAAe,CAAC,EAAE;QACrCD,eAAe,CAACC,eAAe,CAAC,GAAG;UACjCC,IAAI,EAAED,eAAe;UACrBE,YAAY,EAAEJ,WAAW,CAACE,eAAe,CAAC,CAACG,WAAW;UACtDC,aAAa,EAAE,IAAI;UAAE;UACrBC,aAAa,EAAE,IAAI;UAAE;UACrBC,KAAK,EAAE,CAAC,CAAC;QACX,CAAC;MACH,CAAC,MAAM;QACL;QACAP,eAAe,CAACC,eAAe,CAAC,CAACK,aAAa,GAAG,IAAI;MACvD;IACF;;IAEA;IACA3C,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC,GAAG;MACpBW,KAAK,EAAEiB,eAAe;MACtBb,MAAM;MACNC,QAAQ;MACRW;IACF,CAAC;IAED,OAAOpC,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC;EAC5B,CAAC,CAAC,OAAOO,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,8BAA8BP,IAAI,GAAG,EAAEO,KAAK,CAAC;IAC3D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM6B,cAAc,GAAG,MAAAA,CAAOC,KAAK,EAAErC,IAAI,KAAK;EACnD,MAAMsC,OAAO,GAAG,EAAE;EAClB,MAAMC,MAAM,GAAG,EAAE;EAEjB,IAAI;IACF;IACA,MAAMC,OAAO,GAAG,MAAMzC,WAAW,CAACC,IAAI,CAAC;IACvCE,OAAO,CAACC,GAAG,CAAC,oBAAoBiB,MAAM,CAACC,IAAI,CAACmB,OAAO,CAAC7B,KAAK,CAAC,CAACW,MAAM,kBAAkB,CAAC;;IAEpF;IACA,MAAM;MAAEX,KAAK;MAAE8B;IAAkB,CAAC,GAAG/D,cAAc,CAAC2D,KAAK,CAAC;IAC1DnC,OAAO,CAACC,GAAG,CAAC,iBAAiBkC,KAAK,8BAA8B,EAAE1B,KAAK,CAAC;;IAExE;IACA,KAAK,MAAM+B,OAAO,IAAI/B,KAAK,EAAE;MAC3B,MAAMgC,IAAI,GAAGlE,aAAa,CAACiE,OAAO,CAAC;;MAEnC;MACA,IAAItD,cAAc,CAACuD,IAAI,CAAC,KAAK,KAAK,EAAE;QAClCzC,OAAO,CAACC,GAAG,CAAC,0BAA0BwC,IAAI,EAAE,CAAC;QAC7C;MACF;MAEAzC,OAAO,CAACC,GAAG,CAAC,wBAAwBuC,OAAO,mBAAmBC,IAAI,IAAI,CAAC;;MAEvE;MACA,IAAIhE,gBAAgB,CAACgE,IAAI,CAAC,EAAE;QAC1B,MAAMC,YAAY,GAAGhE,mBAAmB,CAAC+D,IAAI,EAAEH,OAAO,CAAC7B,KAAK,CAAC;QAE7D,IAAIiC,YAAY,CAACtB,MAAM,KAAK,CAAC,EAAE;UAC7BiB,MAAM,CAACM,IAAI,CAAC,yCAAyCH,OAAO,EAAE,CAAC;QACjE,CAAC,MAAM;UACLE,YAAY,CAACE,OAAO,CAACC,WAAW,IAAI;YAClC,MAAMC,QAAQ,GAAGR,OAAO,CAAC7B,KAAK,CAACoC,WAAW,CAAC;YAC3CT,OAAO,CAACO,IAAI,CAAC;cACXf,IAAI,EAAEiB,WAAW;cACjBhB,YAAY,EAAEiB,QAAQ,CAACjB,YAAY;cACnCkB,MAAM,EAAEjE,YAAY,CAAC+D,WAAW,EAAEP,OAAO,CAACzB,MAAM,CAAC;cACjDmC,OAAO,EAAEnE,cAAc,CAACgE,WAAW,EAAEP,OAAO,CAAC7B,KAAK,EAAE6B,OAAO,CAACxB,QAAQ,CAAC;cACrEmC,QAAQ,EAAE;YACZ,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ;QACA;MACF;;MAEA;MACA,IAAI,CAAC5E,gBAAgB,CAACoE,IAAI,CAAC,EAAE;QAC3BJ,MAAM,CAACM,IAAI,CAAC,iGAAiGH,OAAO,EAAE,CAAC;QACvH;MACF;;MAEA;MACA,IAAIF,OAAO,CAAC7B,KAAK,CAACgC,IAAI,CAAC,EAAE;QACvB,MAAMK,QAAQ,GAAGR,OAAO,CAAC7B,KAAK,CAACgC,IAAI,CAAC;;QAEpC;QACA,IAAIK,QAAQ,CAACf,aAAa,IAAI,CAACU,IAAI,CAACS,QAAQ,CAAC,GAAG,CAAC,EAAE;UACjD;UACAlD,OAAO,CAACC,GAAG,CAAC,GAAGwC,IAAI,yEAAyE,CAAC;UAC7F,MAAMU,UAAU,GAAGxE,iBAAiB,CAAC8D,IAAI,EAAEH,OAAO,CAAC7B,KAAK,CAAC;UAEzD,IAAI0C,UAAU,CAAC/B,MAAM,GAAG,CAAC,EAAE;YACzB;YACAgB,OAAO,CAACO,IAAI,CAAC;cACXf,IAAI,EAAEa,IAAI;cACVZ,YAAY,EAAEiB,QAAQ,CAACjB,YAAY;cACnCkB,MAAM,EAAEjE,YAAY,CAAC2D,IAAI,EAAEH,OAAO,CAACzB,MAAM,CAAC;cAC1CmC,OAAO,EAAEnE,cAAc,CAAC4D,IAAI,EAAEH,OAAO,CAAC7B,KAAK,EAAE6B,OAAO,CAACxB,QAAQ,CAAC;cAC9DmC,QAAQ,EAAE,IAAI,CAAC;YACjB,CAAC,CAAC;;YAEF;YACAE,UAAU,CAACP,OAAO,CAACQ,SAAS,IAAI;cAC9B;cACA,IAAIA,SAAS,KAAKX,IAAI,EAAE;cAExBL,OAAO,CAACO,IAAI,CAAC;gBACXf,IAAI,EAAEwB,SAAS;gBACfvB,YAAY,EAAES,OAAO,CAAC7B,KAAK,CAAC2C,SAAS,CAAC,CAACvB,YAAY;gBACnDkB,MAAM,EAAEjE,YAAY,CAACsE,SAAS,EAAEd,OAAO,CAACzB,MAAM,CAAC;gBAC/CmC,OAAO,EAAEnE,cAAc,CAACuE,SAAS,EAAEd,OAAO,CAAC7B,KAAK,EAAE6B,OAAO,CAACxB,QAAQ,CAAC;gBACnEuC,UAAU,EAAEZ,IAAI,CAAC;cACnB,CAAC,CAAC;YACJ,CAAC,CAAC;UACJ,CAAC,MAAM;YACL;YACAL,OAAO,CAACO,IAAI,CAAC;cACXf,IAAI,EAAEa,IAAI;cACVZ,YAAY,EAAEiB,QAAQ,CAACjB,YAAY;cACnCkB,MAAM,EAAEjE,YAAY,CAAC2D,IAAI,EAAEH,OAAO,CAACzB,MAAM,CAAC;cAC1CmC,OAAO,EAAEnE,cAAc,CAAC4D,IAAI,EAAEH,OAAO,CAAC7B,KAAK,EAAE6B,OAAO,CAACxB,QAAQ;YAC/D,CAAC,CAAC;UACJ;QACF,CAAC,MAAM;UACL;UACAsB,OAAO,CAACO,IAAI,CAAC;YACXf,IAAI,EAAEa,IAAI;YACVZ,YAAY,EAAEiB,QAAQ,CAACjB,YAAY;YACnCkB,MAAM,EAAEjE,YAAY,CAAC2D,IAAI,EAAEH,OAAO,CAACzB,MAAM,CAAC;YAC1CmC,OAAO,EAAEnE,cAAc,CAAC4D,IAAI,EAAEH,OAAO,CAAC7B,KAAK,EAAE6B,OAAO,CAACxB,QAAQ;UAC/D,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL;QACA,MAAMqC,UAAU,GAAGxE,iBAAiB,CAAC8D,IAAI,EAAEH,OAAO,CAAC7B,KAAK,CAAC;QAEzD,IAAI0C,UAAU,CAAC/B,MAAM,GAAG,CAAC,EAAE;UACzBpB,OAAO,CAACC,GAAG,CAAC,GAAGwC,IAAI,sCAAsCU,UAAU,CAAC/B,MAAM,mBAAmB,CAAC;UAC9F;UACA+B,UAAU,CAACP,OAAO,CAACQ,SAAS,IAAI;YAC9BhB,OAAO,CAACO,IAAI,CAAC;cACXf,IAAI,EAAEwB,SAAS;cACfvB,YAAY,EAAES,OAAO,CAAC7B,KAAK,CAAC2C,SAAS,CAAC,CAACvB,YAAY;cACnDkB,MAAM,EAAEjE,YAAY,CAACsE,SAAS,EAAEd,OAAO,CAACzB,MAAM,CAAC;cAC/CmC,OAAO,EAAEnE,cAAc,CAACuE,SAAS,EAAEd,OAAO,CAAC7B,KAAK,EAAE6B,OAAO,CAACxB,QAAQ,CAAC;cACnEwC,UAAU,EAAEb,IAAI,CAAC;YACnB,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ,CAAC,MAAM;UACLJ,MAAM,CAACM,IAAI,CAAC,0BAA0B7C,IAAI,eAAe0C,OAAO,EAAE,CAAC;QACrE;MACF;IACF;IAEAxC,OAAO,CAACC,GAAG,CAAC,8BAA8BmC,OAAO,CAAChB,MAAM,UAAU,CAAC;IACnE,OAAO;MACLgB,OAAO;MACPG,iBAAiB;MACjBF;IACF,CAAC;EACH,CAAC,CAAC,OAAOhC,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClDgC,MAAM,CAACM,IAAI,CAAC,yBAAyBtC,KAAK,CAACkD,OAAO,EAAE,CAAC;IACrD,OAAO;MAAEnB,OAAO;MAAEG,iBAAiB,EAAE,CAAC;MAAEF;IAAO,CAAC;EAClD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMmB,cAAc,GAAG,MAAAA,CAAOrB,KAAK,EAAErC,IAAI,EAAE2D,cAAc,GAAG,KAAK,KAAK;EAC3E,MAAMrB,OAAO,GAAG,EAAE;EAClB,MAAMC,MAAM,GAAG,EAAE;EAEjB,IAAI;IACF;IACA,MAAMqB,OAAO,GAAG,MAAMpC,WAAW,CAACxB,IAAI,CAAC;IACvCE,OAAO,CAACC,GAAG,CAAC,oBAAoBiB,MAAM,CAACC,IAAI,CAACuC,OAAO,CAACjD,KAAK,CAAC,CAACW,MAAM,kBAAkB,CAAC;;IAEpF;IACA,MAAM;MAAEX,KAAK;MAAE8B;IAAkB,CAAC,GAAG/D,cAAc,CAAC2D,KAAK,CAAC;IAC1DnC,OAAO,CAACC,GAAG,CAAC,iBAAiBkC,KAAK,8BAA8B,EAAE1B,KAAK,CAAC;;IAExE;IACA,KAAK,MAAM+B,OAAO,IAAI/B,KAAK,EAAE;MAC3B,MAAMgC,IAAI,GAAGlE,aAAa,CAACiE,OAAO,CAAC;;MAEnC;MACA,IAAItD,cAAc,CAACuD,IAAI,CAAC,KAAK,KAAK,EAAE;QAClCzC,OAAO,CAACC,GAAG,CAAC,0BAA0BwC,IAAI,EAAE,CAAC;QAC7C;MACF;;MAEA;MACA,MAAMkB,aAAa,GAAGxE,aAAa,CAACsD,IAAI,CAAC;MAEzCzC,OAAO,CAACC,GAAG,CAAC,wBAAwBuC,OAAO,mBAAmBC,IAAI,kBAAkBkB,aAAa,IAAI,CAAC;;MAEtG;MACA,IAAIlF,gBAAgB,CAACkF,aAAa,CAAC,EAAE;QACnC,MAAMjB,YAAY,GAAGhE,mBAAmB,CAACiF,aAAa,EAAED,OAAO,CAACjD,KAAK,CAAC;QAEtE,IAAIiC,YAAY,CAACtB,MAAM,KAAK,CAAC,EAAE;UAC7BiB,MAAM,CAACM,IAAI,CAAC,yCAAyCH,OAAO,EAAE,CAAC;QACjE,CAAC,MAAM;UACLE,YAAY,CAACE,OAAO,CAACC,WAAW,IAAI;YAAA,IAAAe,qBAAA;YAClC,MAAMd,QAAQ,GAAGY,OAAO,CAACjD,KAAK,CAACoC,WAAW,CAAC;YAC3CT,OAAO,CAACO,IAAI,CAAC;cACXf,IAAI,EAAEiB,WAAW;cACjBhB,YAAY,EAAEiB,QAAQ,CAACjB,YAAY;cACnCkB,MAAM,EAAE/D,YAAY,CAAC6D,WAAW,EAAEa,OAAO,CAAC7C,MAAM,CAAC;cACjDmC,OAAO,EAAEjE,cAAc,CAAC8D,WAAW,EAAEa,OAAO,CAAC5C,QAAQ,CAAC;cACtDW,WAAW,EAAE,EAAAmC,qBAAA,GAAAxE,oBAAoB,CAACuE,aAAa,EAAED,OAAO,CAACjC,WAAW,CAAC,cAAAmC,qBAAA,uBAAxDA,qBAAA,CAA0D9B,WAAW,KAAI,EAAE;cACxFmB,QAAQ,EAAEH,QAAQ,CAACf;YACrB,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ;QACA;MACF;;MAEA;MACA,IAAI,CAACzD,gBAAgB,CAACqF,aAAa,CAAC,EAAE;QACpCtB,MAAM,CAACM,IAAI,CAAC,qGAAqGH,OAAO,EAAE,CAAC;QAC3H;MACF;;MAEA;MACA,IAAIkB,OAAO,CAACjD,KAAK,CAACkD,aAAa,CAAC,EAAE;QAChC,MAAMb,QAAQ,GAAGY,OAAO,CAACjD,KAAK,CAACkD,aAAa,CAAC;;QAE7C;QACA,MAAME,eAAe,GAAGzE,oBAAoB,CAACuE,aAAa,EAAED,OAAO,CAACjC,WAAW,CAAC;;QAEhF;QACAW,OAAO,CAACO,IAAI,CAAC;UACXf,IAAI,EAAE+B,aAAa;UACnB9B,YAAY,EAAEiB,QAAQ,CAACjB,YAAY;UACnCkB,MAAM,EAAE/D,YAAY,CAAC2E,aAAa,EAAED,OAAO,CAAC7C,MAAM,CAAC;UACnDmC,OAAO,EAAEjE,cAAc,CAAC4E,aAAa,EAAED,OAAO,CAAC5C,QAAQ,CAAC;UACxDW,WAAW,EAAEoC,eAAe,GAAGA,eAAe,CAAC/B,WAAW,GAAG,EAAE;UAC/DmB,QAAQ,EAAEH,QAAQ,CAACf;QACrB,CAAC,CAAC;;QAEF;QACA;QACA,IAAI0B,cAAc,IAAIX,QAAQ,CAACf,aAAa,EAAE;UAC5C/B,OAAO,CAACC,GAAG,CAAC,GAAG0D,aAAa,6EAA6E,CAAC;UAC1G,MAAMR,UAAU,GAAGvE,iBAAiB,CAAC+E,aAAa,EAAED,OAAO,CAACjD,KAAK,CAAC;UAElE,IAAI0C,UAAU,CAAC/B,MAAM,GAAG,CAAC,EAAE;YACzB;YACA+B,UAAU,CAACP,OAAO,CAACQ,SAAS,IAAI;cAC9B;cACA,IAAIA,SAAS,KAAKO,aAAa,EAAE;cAEjC,MAAMG,oBAAoB,GAAG1E,oBAAoB,CAACgE,SAAS,EAAEM,OAAO,CAACjC,WAAW,CAAC;cAEjFW,OAAO,CAACO,IAAI,CAAC;gBACXf,IAAI,EAAEwB,SAAS;gBACfvB,YAAY,EAAE6B,OAAO,CAACjD,KAAK,CAAC2C,SAAS,CAAC,CAACvB,YAAY;gBACnDkB,MAAM,EAAE/D,YAAY,CAACoE,SAAS,EAAEM,OAAO,CAAC7C,MAAM,CAAC;gBAC/CmC,OAAO,EAAEjE,cAAc,CAACqE,SAAS,EAAEM,OAAO,CAAC5C,QAAQ,CAAC;gBACpDW,WAAW,EAAEqC,oBAAoB,GAAGA,oBAAoB,CAAChC,WAAW,GAAG,EAAE;gBACzEuB,UAAU,EAAEM,aAAa,CAAC;cAC5B,CAAC,CAAC;YACJ,CAAC,CAAC;UACJ;QACF;MACF,CAAC,MAAM;QACL;QACA,MAAMI,gBAAgB,GAAGJ,aAAa,CAACK,KAAK,CAAC,cAAc,CAAC;QAE5D,IAAID,gBAAgB,EAAE;UACpB,MAAMpC,eAAe,GAAGoC,gBAAgB,CAAC,CAAC,CAAC;UAC3C,MAAMF,eAAe,GAAGzE,oBAAoB,CAACuC,eAAe,EAAE+B,OAAO,CAACjC,WAAW,CAAC;UAElF,IAAIoC,eAAe,EAAE;YACnB;YACAzB,OAAO,CAACO,IAAI,CAAC;cACXf,IAAI,EAAED,eAAe;cACrBE,YAAY,EAAEgC,eAAe,CAAC/B,WAAW;cACzCiB,MAAM,EAAEc,eAAe,CAAC/B,WAAW;cACnCkB,OAAO,EAAEjE,cAAc,CAAC4C,eAAe,EAAE+B,OAAO,CAAC5C,QAAQ,CAAC;cAC1DW,WAAW,EAAEoC,eAAe,CAAC/B,WAAW;cACxCmB,QAAQ,EAAE;YACZ,CAAC,CAAC;;YAEF;YACA,IAAIQ,cAAc,EAAE;cAClB,MAAMQ,YAAY,GAAG,IAAIC,MAAM,CAAC,IAAIvC,eAAe,KAAK,CAAC;cACzD,MAAMwB,UAAU,GAAGjC,MAAM,CAACC,IAAI,CAACuC,OAAO,CAACjD,KAAK,CAAC,CAAC0D,MAAM,CAAC1B,IAAI,IACvDwB,YAAY,CAACG,IAAI,CAAC3B,IAAI,CACxB,CAAC;cAED,IAAIU,UAAU,CAAC/B,MAAM,GAAG,CAAC,EAAE;gBACzB+B,UAAU,CAACP,OAAO,CAACQ,SAAS,IAAI;kBAC9B,MAAMiB,SAAS,GAAGX,OAAO,CAACjD,KAAK,CAAC2C,SAAS,CAAC;kBAC1ChB,OAAO,CAACO,IAAI,CAAC;oBACXf,IAAI,EAAEwB,SAAS;oBACfvB,YAAY,EAAEwC,SAAS,CAACxC,YAAY;oBACpCkB,MAAM,EAAEc,eAAe,CAAC/B,WAAW;oBACnCkB,OAAO,EAAEjE,cAAc,CAACqE,SAAS,EAAEM,OAAO,CAAC5C,QAAQ,CAAC;oBACpDW,WAAW,EAAEoC,eAAe,CAAC/B,WAAW;oBACxCuB,UAAU,EAAE1B;kBACd,CAAC,CAAC;gBACJ,CAAC,CAAC;cACJ;YACF;UACF,CAAC,MAAM;YACLU,MAAM,CAACM,IAAI,CAAC,0BAA0B7C,IAAI,eAAe0C,OAAO,EAAE,CAAC;UACrE;QACF,CAAC,MAAM;UACLH,MAAM,CAACM,IAAI,CAAC,0BAA0B7C,IAAI,eAAe0C,OAAO,EAAE,CAAC;QACrE;MACF;IACF;IAEAxC,OAAO,CAACC,GAAG,CAAC,8BAA8BmC,OAAO,CAAChB,MAAM,UAAU,CAAC;IACnE,OAAO;MACLgB,OAAO;MACPG,iBAAiB;MACjBF;IACF,CAAC;EACH,CAAC,CAAC,OAAOhC,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClDgC,MAAM,CAACM,IAAI,CAAC,yBAAyBtC,KAAK,CAACkD,OAAO,EAAE,CAAC;IACrD,OAAO;MAAEnB,OAAO;MAAEG,iBAAiB,EAAE,CAAC;MAAEF;IAAO,CAAC;EAClD;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}