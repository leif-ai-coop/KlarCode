{"ast":null,"code":"import { parseICDCodes, parseICDGroups, parseICDChapters, parseOPSCodes, parseOPSGroups, parseOPSChapters, parseOPSDreisteller } from '../utils/parser';\nimport { isValidICDFormat, isValidOPSFormat, normalizeCode, parseUserInput, isWildcardSearch, findWildcardMatches, findChildICDCodes, findChildOPSCodes, findICDChapter, findICDGroup, findOPSChapter, findOPSGroup, findOPSDreisteller } from '../utils/search';\n\n// Cache für geladene Daten\nconst dataCache = {\n  icd: {},\n  ops: {}\n};\n\n/**\r\n * Get the current year or fallback to 2025 if not available\r\n * @returns {string} - The current year\r\n */\nexport const getCurrentYear = () => {\n  const currentYear = new Date().getFullYear();\n  return currentYear >= 2025 && currentYear <= 2026 ? currentYear.toString() : '2025';\n};\n\n/**\r\n * Load all ICD-10 data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\nexport const loadICDData = async year => {\n  // Check if data is already cached\n  if (dataCache.icd[year]) {\n    return dataCache.icd[year];\n  }\n  try {\n    // Verschiedene Pfadvarianten testen\n    let baseUrl = `/data/${year}/icd10/`;\n\n    // Logging hinzufügen, um das Problem besser zu verstehen\n    console.log(`Attempting to load ICD data from: ${baseUrl}`);\n\n    // Load all required files\n    const codesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\n    if (!codesResponse.ok) {\n      console.error(`Failed to load ICD-10 codes: ${codesResponse.status}, trying alternative path...`);\n\n      // Alternative paths to try\n      baseUrl = `/src/data/${year}/icd10/`;\n      console.log(`Trying alternative path: ${baseUrl}`);\n      const altCodesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\n      if (!altCodesResponse.ok) {\n        console.error(`Failed to load ICD-10 codes from alternative path: ${altCodesResponse.status}`);\n        throw new Error(`Failed to load ICD-10 data for ${year}`);\n      }\n      console.log(\"Successfully loaded ICD data from alternative path!\");\n      const codes = parseICDCodes(await altCodesResponse.text());\n\n      // Load other files\n      const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\n      const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\n      if (!groupsResponse.ok || !chaptersResponse.ok) {\n        throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\n      }\n      const groups = parseICDGroups(await groupsResponse.text());\n      const chapters = parseICDChapters(await chaptersResponse.text());\n\n      // Cache the data\n      dataCache.icd[year] = {\n        codes,\n        groups,\n        chapters\n      };\n      return dataCache.icd[year];\n    }\n\n    // Ursprünglicher Code für den Fall, dass der erste Pfad funktioniert\n    console.log(\"Successfully loaded ICD data from original path!\");\n    const codesText = await codesResponse.text();\n    const codes = parseICDCodes(codesText);\n    const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\n    const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\n    if (!groupsResponse.ok || !chaptersResponse.ok) {\n      throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\n    }\n    const groupsText = await groupsResponse.text();\n    const chaptersText = await chaptersResponse.text();\n\n    // Parse the data\n    const groups = parseICDGroups(groupsText);\n    const chapters = parseICDChapters(chaptersText);\n\n    // Cache the data\n    dataCache.icd[year] = {\n      codes,\n      groups,\n      chapters\n    };\n\n    // Datenzusammenfassung ausgeben\n    console.log(`Loaded ${Object.keys(codes).length} ICD codes`);\n    console.log(`Sample codes:`, Object.keys(codes).slice(0, 5));\n    return dataCache.icd[year];\n  } catch (error) {\n    console.error(`Error loading ICD data for ${year}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Load all OPS data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\nexport const loadOPSData = async year => {\n  // Check if data is already cached\n  if (dataCache.ops[year]) {\n    return dataCache.ops[year];\n  }\n  try {\n    // Load all required files\n    const codesResponse = await fetch(`/data/${year}/ops/ops${year}syst_kodes.txt`);\n    const groupsResponse = await fetch(`/data/${year}/ops/ops${year}syst_gruppen.txt`);\n    const chaptersResponse = await fetch(`/data/${year}/ops/ops${year}syst_kapitel.txt`);\n    const dreistellerResponse = await fetch(`/data/${year}/ops/ops${year}syst_dreisteller.txt`);\n    if (!codesResponse.ok || !groupsResponse.ok || !chaptersResponse.ok || !dreistellerResponse.ok) {\n      throw new Error(`Failed to load OPS data for ${year}`);\n    }\n    const codesText = await codesResponse.text();\n    const groupsText = await groupsResponse.text();\n    const chaptersText = await chaptersResponse.text();\n    const dreistellerText = await dreistellerResponse.text();\n\n    // Parse the data\n    const codes = parseOPSCodes(codesText);\n    const groups = parseOPSGroups(groupsText);\n    const chapters = parseOPSChapters(chaptersText);\n    const dreisteller = parseOPSDreisteller(dreistellerText);\n\n    // Cache the data\n    dataCache.ops[year] = {\n      codes,\n      groups,\n      chapters,\n      dreisteller\n    };\n    return dataCache.ops[year];\n  } catch (error) {\n    console.error(`Error loading OPS data for ${year}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Search for ICD-10 codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\nexport const searchICDCodes = async (input, year) => {\n  const results = [];\n  const errors = [];\n  try {\n    // Load or get cached data\n    const icdData = await loadICDData(year);\n    console.log(`ICD Data loaded, ${Object.keys(icdData.codes).length} codes available`);\n\n    // Parse user input\n    const {\n      codes,\n      duplicatesRemoved\n    } = parseUserInput(input);\n    console.log(`Parsed input \"${input}\" into codes:`, codes);\n\n    // Process each code\n    for (const rawCode of codes) {\n      const code = normalizeCode(rawCode);\n      console.log(`Processing code \"${rawCode}\" (normalized: \"${code}\")`);\n\n      // Validate code format\n      if (!isValidICDFormat(code)) {\n        console.log(`Invalid ICD format: ${code}`);\n        errors.push(`Formatfehler: ICD-Codes müssen im Format A00, A00.1 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\n        continue;\n      }\n      console.log(`Valid ICD format: ${code}, checking if exists in database...`);\n\n      // Check if code exists directly\n      if (icdData.codes[code]) {\n        console.log(`Code ${code} found in database`);\n        results.push({\n          kode: code,\n          beschreibung: icdData.codes[code].beschreibung,\n          gruppe: findICDGroup(code, icdData.groups),\n          kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\n        });\n      } else {\n        console.log(`Code ${code} not found directly, checking for child codes...`);\n\n        // Check if it's a parent code without children\n        const childCodes = findChildICDCodes(code, icdData.codes);\n        console.log(`Found ${childCodes.length} child codes for ${code}`);\n        if (childCodes.length > 0) {\n          // Add all child codes\n          childCodes.forEach(childCode => {\n            results.push({\n              kode: childCode,\n              beschreibung: icdData.codes[childCode].beschreibung,\n              gruppe: findICDGroup(childCode, icdData.groups),\n              kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters)\n            });\n          });\n        } else {\n          errors.push(`ICD-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n        }\n      }\n    }\n    console.log(`ICD search complete, found ${results.length} results`);\n    return {\n      results,\n      duplicatesRemoved,\n      errors\n    };\n  } catch (error) {\n    console.error('Error searching ICD codes:', error);\n    errors.push(`Fehler bei der Suche: ${error.message}`);\n    return {\n      results,\n      duplicatesRemoved: 0,\n      errors\n    };\n  }\n};\n\n/**\r\n * Search for OPS codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\nexport const searchOPSCodes = async (input, year) => {\n  const results = [];\n  const errors = [];\n  try {\n    // Load or get cached data\n    const opsData = await loadOPSData(year);\n\n    // Parse user input\n    const {\n      codes,\n      duplicatesRemoved\n    } = parseUserInput(input);\n\n    // Process each code\n    for (const rawCode of codes) {\n      const code = normalizeCode(rawCode);\n\n      // Handle wildcard search\n      if (isWildcardSearch(code)) {\n        const matchedCodes = findWildcardMatches(code, opsData.codes);\n        if (matchedCodes.length === 0) {\n          errors.push(`Keine passenden OPS-Codes für Muster: ${rawCode}`);\n        } else {\n          matchedCodes.forEach(matchedCode => {\n            const codeData = opsData.codes[matchedCode];\n            results.push({\n              kode: matchedCode,\n              beschreibung: codeData.beschreibung,\n              gruppe: findOPSGroup(matchedCode, opsData.groups),\n              kapitel: findOPSChapter(matchedCode, opsData.chapters),\n              dreisteller: findOPSDreisteller(matchedCode, opsData.dreisteller)\n            });\n          });\n        }\n        continue;\n      }\n\n      // Validate code format\n      if (!isValidOPSFormat(code)) {\n        errors.push(`Formatfehler: OPS-Codes müssen im Format 1-20, 1-202.00 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\n        continue;\n      }\n\n      // Check if code exists directly\n      if (opsData.codes[code]) {\n        results.push({\n          kode: code,\n          beschreibung: opsData.codes[code].beschreibung,\n          gruppe: findOPSGroup(code, opsData.groups),\n          kapitel: findOPSChapter(code, opsData.chapters),\n          dreisteller: findOPSDreisteller(code, opsData.dreisteller)\n        });\n      } else {\n        // Check if it's a parent code without children\n        const childCodes = findChildOPSCodes(code, opsData.codes);\n        if (childCodes.length > 0) {\n          // Add all child codes\n          childCodes.forEach(childCode => {\n            results.push({\n              kode: childCode,\n              beschreibung: opsData.codes[childCode].beschreibung,\n              gruppe: findOPSGroup(childCode, opsData.groups),\n              kapitel: findOPSChapter(childCode, opsData.chapters),\n              dreisteller: findOPSDreisteller(childCode, opsData.dreisteller)\n            });\n          });\n        } else {\n          errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n        }\n      }\n    }\n    return {\n      results,\n      duplicatesRemoved,\n      errors\n    };\n  } catch (error) {\n    console.error('Error searching OPS codes:', error);\n    errors.push(`Fehler bei der Suche: ${error.message}`);\n    return {\n      results,\n      duplicatesRemoved: 0,\n      errors\n    };\n  }\n};","map":{"version":3,"names":["parseICDCodes","parseICDGroups","parseICDChapters","parseOPSCodes","parseOPSGroups","parseOPSChapters","parseOPSDreisteller","isValidICDFormat","isValidOPSFormat","normalizeCode","parseUserInput","isWildcardSearch","findWildcardMatches","findChildICDCodes","findChildOPSCodes","findICDChapter","findICDGroup","findOPSChapter","findOPSGroup","findOPSDreisteller","dataCache","icd","ops","getCurrentYear","currentYear","Date","getFullYear","toString","loadICDData","year","baseUrl","console","log","codesResponse","fetch","ok","error","status","altCodesResponse","Error","codes","text","groupsResponse","chaptersResponse","groups","chapters","codesText","groupsText","chaptersText","Object","keys","length","slice","loadOPSData","dreistellerResponse","dreistellerText","dreisteller","searchICDCodes","input","results","errors","icdData","duplicatesRemoved","rawCode","code","push","kode","beschreibung","gruppe","kapitel","childCodes","forEach","childCode","message","searchOPSCodes","opsData","matchedCodes","matchedCode","codeData"],"sources":["C:/Code/KlarCode/src/services/dataService.js"],"sourcesContent":["import { \r\n  parseICDCodes, \r\n  parseICDGroups, \r\n  parseICDChapters,\r\n  parseOPSCodes,\r\n  parseOPSGroups,\r\n  parseOPSChapters,\r\n  parseOPSDreisteller\r\n} from '../utils/parser';\r\n\r\nimport {\r\n  isValidICDFormat,\r\n  isValidOPSFormat,\r\n  normalizeCode,\r\n  parseUserInput,\r\n  isWildcardSearch,\r\n  findWildcardMatches,\r\n  findChildICDCodes,\r\n  findChildOPSCodes,\r\n  findICDChapter,\r\n  findICDGroup,\r\n  findOPSChapter,\r\n  findOPSGroup,\r\n  findOPSDreisteller\r\n} from '../utils/search';\r\n\r\n// Cache für geladene Daten\r\nconst dataCache = {\r\n  icd: {},\r\n  ops: {}\r\n};\r\n\r\n/**\r\n * Get the current year or fallback to 2025 if not available\r\n * @returns {string} - The current year\r\n */\r\nexport const getCurrentYear = () => {\r\n  const currentYear = new Date().getFullYear();\r\n  return currentYear >= 2025 && currentYear <= 2026 ? currentYear.toString() : '2025';\r\n};\r\n\r\n/**\r\n * Load all ICD-10 data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\r\nexport const loadICDData = async (year) => {\r\n  // Check if data is already cached\r\n  if (dataCache.icd[year]) {\r\n    return dataCache.icd[year];\r\n  }\r\n  \r\n  try {\r\n    // Verschiedene Pfadvarianten testen\r\n    let baseUrl = `/data/${year}/icd10/`;\r\n    \r\n    // Logging hinzufügen, um das Problem besser zu verstehen\r\n    console.log(`Attempting to load ICD data from: ${baseUrl}`);\r\n    \r\n    // Load all required files\r\n    const codesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\r\n    \r\n    if (!codesResponse.ok) {\r\n      console.error(`Failed to load ICD-10 codes: ${codesResponse.status}, trying alternative path...`);\r\n      \r\n      // Alternative paths to try\r\n      baseUrl = `/src/data/${year}/icd10/`;\r\n      console.log(`Trying alternative path: ${baseUrl}`);\r\n      \r\n      const altCodesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\r\n      \r\n      if (!altCodesResponse.ok) {\r\n        console.error(`Failed to load ICD-10 codes from alternative path: ${altCodesResponse.status}`);\r\n        throw new Error(`Failed to load ICD-10 data for ${year}`);\r\n      }\r\n      \r\n      console.log(\"Successfully loaded ICD data from alternative path!\");\r\n      const codes = parseICDCodes(await altCodesResponse.text());\r\n      \r\n      // Load other files\r\n      const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\r\n      const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\r\n      \r\n      if (!groupsResponse.ok || !chaptersResponse.ok) {\r\n        throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\r\n      }\r\n      \r\n      const groups = parseICDGroups(await groupsResponse.text());\r\n      const chapters = parseICDChapters(await chaptersResponse.text());\r\n      \r\n      // Cache the data\r\n      dataCache.icd[year] = { codes, groups, chapters };\r\n      \r\n      return dataCache.icd[year];\r\n    }\r\n    \r\n    // Ursprünglicher Code für den Fall, dass der erste Pfad funktioniert\r\n    console.log(\"Successfully loaded ICD data from original path!\");\r\n    const codesText = await codesResponse.text();\r\n    const codes = parseICDCodes(codesText);\r\n    \r\n    const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\r\n    const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\r\n    \r\n    if (!groupsResponse.ok || !chaptersResponse.ok) {\r\n      throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\r\n    }\r\n    \r\n    const groupsText = await groupsResponse.text();\r\n    const chaptersText = await chaptersResponse.text();\r\n    \r\n    // Parse the data\r\n    const groups = parseICDGroups(groupsText);\r\n    const chapters = parseICDChapters(chaptersText);\r\n    \r\n    // Cache the data\r\n    dataCache.icd[year] = { codes, groups, chapters };\r\n    \r\n    // Datenzusammenfassung ausgeben\r\n    console.log(`Loaded ${Object.keys(codes).length} ICD codes`);\r\n    console.log(`Sample codes:`, Object.keys(codes).slice(0, 5));\r\n    \r\n    return dataCache.icd[year];\r\n  } catch (error) {\r\n    console.error(`Error loading ICD data for ${year}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Load all OPS data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\r\nexport const loadOPSData = async (year) => {\r\n  // Check if data is already cached\r\n  if (dataCache.ops[year]) {\r\n    return dataCache.ops[year];\r\n  }\r\n  \r\n  try {\r\n    // Load all required files\r\n    const codesResponse = await fetch(`/data/${year}/ops/ops${year}syst_kodes.txt`);\r\n    const groupsResponse = await fetch(`/data/${year}/ops/ops${year}syst_gruppen.txt`);\r\n    const chaptersResponse = await fetch(`/data/${year}/ops/ops${year}syst_kapitel.txt`);\r\n    const dreistellerResponse = await fetch(`/data/${year}/ops/ops${year}syst_dreisteller.txt`);\r\n    \r\n    if (!codesResponse.ok || !groupsResponse.ok || !chaptersResponse.ok || !dreistellerResponse.ok) {\r\n      throw new Error(`Failed to load OPS data for ${year}`);\r\n    }\r\n    \r\n    const codesText = await codesResponse.text();\r\n    const groupsText = await groupsResponse.text();\r\n    const chaptersText = await chaptersResponse.text();\r\n    const dreistellerText = await dreistellerResponse.text();\r\n    \r\n    // Parse the data\r\n    const codes = parseOPSCodes(codesText);\r\n    const groups = parseOPSGroups(groupsText);\r\n    const chapters = parseOPSChapters(chaptersText);\r\n    const dreisteller = parseOPSDreisteller(dreistellerText);\r\n    \r\n    // Cache the data\r\n    dataCache.ops[year] = { codes, groups, chapters, dreisteller };\r\n    \r\n    return dataCache.ops[year];\r\n  } catch (error) {\r\n    console.error(`Error loading OPS data for ${year}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Search for ICD-10 codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\r\nexport const searchICDCodes = async (input, year) => {\r\n  const results = [];\r\n  const errors = [];\r\n  \r\n  try {\r\n    // Load or get cached data\r\n    const icdData = await loadICDData(year);\r\n    console.log(`ICD Data loaded, ${Object.keys(icdData.codes).length} codes available`);\r\n    \r\n    // Parse user input\r\n    const { codes, duplicatesRemoved } = parseUserInput(input);\r\n    console.log(`Parsed input \"${input}\" into codes:`, codes);\r\n    \r\n    // Process each code\r\n    for (const rawCode of codes) {\r\n      const code = normalizeCode(rawCode);\r\n      console.log(`Processing code \"${rawCode}\" (normalized: \"${code}\")`);\r\n      \r\n      // Validate code format\r\n      if (!isValidICDFormat(code)) {\r\n        console.log(`Invalid ICD format: ${code}`);\r\n        errors.push(`Formatfehler: ICD-Codes müssen im Format A00, A00.1 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`Valid ICD format: ${code}, checking if exists in database...`);\r\n      \r\n      // Check if code exists directly\r\n      if (icdData.codes[code]) {\r\n        console.log(`Code ${code} found in database`);\r\n        results.push({\r\n          kode: code,\r\n          beschreibung: icdData.codes[code].beschreibung,\r\n          gruppe: findICDGroup(code, icdData.groups),\r\n          kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\r\n        });\r\n      } else {\r\n        console.log(`Code ${code} not found directly, checking for child codes...`);\r\n        \r\n        // Check if it's a parent code without children\r\n        const childCodes = findChildICDCodes(code, icdData.codes);\r\n        console.log(`Found ${childCodes.length} child codes for ${code}`);\r\n        \r\n        if (childCodes.length > 0) {\r\n          // Add all child codes\r\n          childCodes.forEach(childCode => {\r\n            results.push({\r\n              kode: childCode,\r\n              beschreibung: icdData.codes[childCode].beschreibung,\r\n              gruppe: findICDGroup(childCode, icdData.groups),\r\n              kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters)\r\n            });\r\n          });\r\n        } else {\r\n          errors.push(`ICD-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`ICD search complete, found ${results.length} results`);\r\n    return {\r\n      results,\r\n      duplicatesRemoved,\r\n      errors\r\n    };\r\n  } catch (error) {\r\n    console.error('Error searching ICD codes:', error);\r\n    errors.push(`Fehler bei der Suche: ${error.message}`);\r\n    return { results, duplicatesRemoved: 0, errors };\r\n  }\r\n};\r\n\r\n/**\r\n * Search for OPS codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\r\nexport const searchOPSCodes = async (input, year) => {\r\n  const results = [];\r\n  const errors = [];\r\n  \r\n  try {\r\n    // Load or get cached data\r\n    const opsData = await loadOPSData(year);\r\n    \r\n    // Parse user input\r\n    const { codes, duplicatesRemoved } = parseUserInput(input);\r\n    \r\n    // Process each code\r\n    for (const rawCode of codes) {\r\n      const code = normalizeCode(rawCode);\r\n      \r\n      // Handle wildcard search\r\n      if (isWildcardSearch(code)) {\r\n        const matchedCodes = findWildcardMatches(code, opsData.codes);\r\n        \r\n        if (matchedCodes.length === 0) {\r\n          errors.push(`Keine passenden OPS-Codes für Muster: ${rawCode}`);\r\n        } else {\r\n          matchedCodes.forEach(matchedCode => {\r\n            const codeData = opsData.codes[matchedCode];\r\n            results.push({\r\n              kode: matchedCode,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findOPSGroup(matchedCode, opsData.groups),\r\n              kapitel: findOPSChapter(matchedCode, opsData.chapters),\r\n              dreisteller: findOPSDreisteller(matchedCode, opsData.dreisteller)\r\n            });\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n      \r\n      // Validate code format\r\n      if (!isValidOPSFormat(code)) {\r\n        errors.push(`Formatfehler: OPS-Codes müssen im Format 1-20, 1-202.00 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\r\n        continue;\r\n      }\r\n      \r\n      // Check if code exists directly\r\n      if (opsData.codes[code]) {\r\n        results.push({\r\n          kode: code,\r\n          beschreibung: opsData.codes[code].beschreibung,\r\n          gruppe: findOPSGroup(code, opsData.groups),\r\n          kapitel: findOPSChapter(code, opsData.chapters),\r\n          dreisteller: findOPSDreisteller(code, opsData.dreisteller)\r\n        });\r\n      } else {\r\n        // Check if it's a parent code without children\r\n        const childCodes = findChildOPSCodes(code, opsData.codes);\r\n        \r\n        if (childCodes.length > 0) {\r\n          // Add all child codes\r\n          childCodes.forEach(childCode => {\r\n            results.push({\r\n              kode: childCode,\r\n              beschreibung: opsData.codes[childCode].beschreibung,\r\n              gruppe: findOPSGroup(childCode, opsData.groups),\r\n              kapitel: findOPSChapter(childCode, opsData.chapters),\r\n              dreisteller: findOPSDreisteller(childCode, opsData.dreisteller)\r\n            });\r\n          });\r\n        } else {\r\n          errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return {\r\n      results,\r\n      duplicatesRemoved,\r\n      errors\r\n    };\r\n  } catch (error) {\r\n    console.error('Error searching OPS codes:', error);\r\n    errors.push(`Fehler bei der Suche: ${error.message}`);\r\n    return { results, duplicatesRemoved: 0, errors };\r\n  }\r\n}; "],"mappings":"AAAA,SACEA,aAAa,EACbC,cAAc,EACdC,gBAAgB,EAChBC,aAAa,EACbC,cAAc,EACdC,gBAAgB,EAChBC,mBAAmB,QACd,iBAAiB;AAExB,SACEC,gBAAgB,EAChBC,gBAAgB,EAChBC,aAAa,EACbC,cAAc,EACdC,gBAAgB,EAChBC,mBAAmB,EACnBC,iBAAiB,EACjBC,iBAAiB,EACjBC,cAAc,EACdC,YAAY,EACZC,cAAc,EACdC,YAAY,EACZC,kBAAkB,QACb,iBAAiB;;AAExB;AACA,MAAMC,SAAS,GAAG;EAChBC,GAAG,EAAE,CAAC,CAAC;EACPC,GAAG,EAAE,CAAC;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAGA,CAAA,KAAM;EAClC,MAAMC,WAAW,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAC5C,OAAOF,WAAW,IAAI,IAAI,IAAIA,WAAW,IAAI,IAAI,GAAGA,WAAW,CAACG,QAAQ,CAAC,CAAC,GAAG,MAAM;AACrF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAG,MAAOC,IAAI,IAAK;EACzC;EACA,IAAIT,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC,EAAE;IACvB,OAAOT,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC;EAC5B;EAEA,IAAI;IACF;IACA,IAAIC,OAAO,GAAG,SAASD,IAAI,SAAS;;IAEpC;IACAE,OAAO,CAACC,GAAG,CAAC,qCAAqCF,OAAO,EAAE,CAAC;;IAE3D;IACA,MAAMG,aAAa,GAAG,MAAMC,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,gBAAgB,CAAC;IAE3E,IAAI,CAACI,aAAa,CAACE,EAAE,EAAE;MACrBJ,OAAO,CAACK,KAAK,CAAC,gCAAgCH,aAAa,CAACI,MAAM,8BAA8B,CAAC;;MAEjG;MACAP,OAAO,GAAG,aAAaD,IAAI,SAAS;MACpCE,OAAO,CAACC,GAAG,CAAC,4BAA4BF,OAAO,EAAE,CAAC;MAElD,MAAMQ,gBAAgB,GAAG,MAAMJ,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,gBAAgB,CAAC;MAE9E,IAAI,CAACS,gBAAgB,CAACH,EAAE,EAAE;QACxBJ,OAAO,CAACK,KAAK,CAAC,sDAAsDE,gBAAgB,CAACD,MAAM,EAAE,CAAC;QAC9F,MAAM,IAAIE,KAAK,CAAC,kCAAkCV,IAAI,EAAE,CAAC;MAC3D;MAEAE,OAAO,CAACC,GAAG,CAAC,qDAAqD,CAAC;MAClE,MAAMQ,KAAK,GAAGxC,aAAa,CAAC,MAAMsC,gBAAgB,CAACG,IAAI,CAAC,CAAC,CAAC;;MAE1D;MACA,MAAMC,cAAc,GAAG,MAAMR,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;MAC9E,MAAMc,gBAAgB,GAAG,MAAMT,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;MAEhF,IAAI,CAACa,cAAc,CAACP,EAAE,IAAI,CAACQ,gBAAgB,CAACR,EAAE,EAAE;QAC9C,MAAM,IAAII,KAAK,CAAC,gDAAgDV,IAAI,EAAE,CAAC;MACzE;MAEA,MAAMe,MAAM,GAAG3C,cAAc,CAAC,MAAMyC,cAAc,CAACD,IAAI,CAAC,CAAC,CAAC;MAC1D,MAAMI,QAAQ,GAAG3C,gBAAgB,CAAC,MAAMyC,gBAAgB,CAACF,IAAI,CAAC,CAAC,CAAC;;MAEhE;MACArB,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC,GAAG;QAAEW,KAAK;QAAEI,MAAM;QAAEC;MAAS,CAAC;MAEjD,OAAOzB,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC;IAC5B;;IAEA;IACAE,OAAO,CAACC,GAAG,CAAC,kDAAkD,CAAC;IAC/D,MAAMc,SAAS,GAAG,MAAMb,aAAa,CAACQ,IAAI,CAAC,CAAC;IAC5C,MAAMD,KAAK,GAAGxC,aAAa,CAAC8C,SAAS,CAAC;IAEtC,MAAMJ,cAAc,GAAG,MAAMR,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;IAC9E,MAAMc,gBAAgB,GAAG,MAAMT,KAAK,CAAC,GAAGJ,OAAO,UAAUD,IAAI,kBAAkB,CAAC;IAEhF,IAAI,CAACa,cAAc,CAACP,EAAE,IAAI,CAACQ,gBAAgB,CAACR,EAAE,EAAE;MAC9C,MAAM,IAAII,KAAK,CAAC,gDAAgDV,IAAI,EAAE,CAAC;IACzE;IAEA,MAAMkB,UAAU,GAAG,MAAML,cAAc,CAACD,IAAI,CAAC,CAAC;IAC9C,MAAMO,YAAY,GAAG,MAAML,gBAAgB,CAACF,IAAI,CAAC,CAAC;;IAElD;IACA,MAAMG,MAAM,GAAG3C,cAAc,CAAC8C,UAAU,CAAC;IACzC,MAAMF,QAAQ,GAAG3C,gBAAgB,CAAC8C,YAAY,CAAC;;IAE/C;IACA5B,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC,GAAG;MAAEW,KAAK;MAAEI,MAAM;MAAEC;IAAS,CAAC;;IAEjD;IACAd,OAAO,CAACC,GAAG,CAAC,UAAUiB,MAAM,CAACC,IAAI,CAACV,KAAK,CAAC,CAACW,MAAM,YAAY,CAAC;IAC5DpB,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEiB,MAAM,CAACC,IAAI,CAACV,KAAK,CAAC,CAACY,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAE5D,OAAOhC,SAAS,CAACC,GAAG,CAACQ,IAAI,CAAC;EAC5B,CAAC,CAAC,OAAOO,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,8BAA8BP,IAAI,GAAG,EAAEO,KAAK,CAAC;IAC3D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMiB,WAAW,GAAG,MAAOxB,IAAI,IAAK;EACzC;EACA,IAAIT,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC,EAAE;IACvB,OAAOT,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC;EAC5B;EAEA,IAAI;IACF;IACA,MAAMI,aAAa,GAAG,MAAMC,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,gBAAgB,CAAC;IAC/E,MAAMa,cAAc,GAAG,MAAMR,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,kBAAkB,CAAC;IAClF,MAAMc,gBAAgB,GAAG,MAAMT,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,kBAAkB,CAAC;IACpF,MAAMyB,mBAAmB,GAAG,MAAMpB,KAAK,CAAC,SAASL,IAAI,WAAWA,IAAI,sBAAsB,CAAC;IAE3F,IAAI,CAACI,aAAa,CAACE,EAAE,IAAI,CAACO,cAAc,CAACP,EAAE,IAAI,CAACQ,gBAAgB,CAACR,EAAE,IAAI,CAACmB,mBAAmB,CAACnB,EAAE,EAAE;MAC9F,MAAM,IAAII,KAAK,CAAC,+BAA+BV,IAAI,EAAE,CAAC;IACxD;IAEA,MAAMiB,SAAS,GAAG,MAAMb,aAAa,CAACQ,IAAI,CAAC,CAAC;IAC5C,MAAMM,UAAU,GAAG,MAAML,cAAc,CAACD,IAAI,CAAC,CAAC;IAC9C,MAAMO,YAAY,GAAG,MAAML,gBAAgB,CAACF,IAAI,CAAC,CAAC;IAClD,MAAMc,eAAe,GAAG,MAAMD,mBAAmB,CAACb,IAAI,CAAC,CAAC;;IAExD;IACA,MAAMD,KAAK,GAAGrC,aAAa,CAAC2C,SAAS,CAAC;IACtC,MAAMF,MAAM,GAAGxC,cAAc,CAAC2C,UAAU,CAAC;IACzC,MAAMF,QAAQ,GAAGxC,gBAAgB,CAAC2C,YAAY,CAAC;IAC/C,MAAMQ,WAAW,GAAGlD,mBAAmB,CAACiD,eAAe,CAAC;;IAExD;IACAnC,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC,GAAG;MAAEW,KAAK;MAAEI,MAAM;MAAEC,QAAQ;MAAEW;IAAY,CAAC;IAE9D,OAAOpC,SAAS,CAACE,GAAG,CAACO,IAAI,CAAC;EAC5B,CAAC,CAAC,OAAOO,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,8BAA8BP,IAAI,GAAG,EAAEO,KAAK,CAAC;IAC3D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMqB,cAAc,GAAG,MAAAA,CAAOC,KAAK,EAAE7B,IAAI,KAAK;EACnD,MAAM8B,OAAO,GAAG,EAAE;EAClB,MAAMC,MAAM,GAAG,EAAE;EAEjB,IAAI;IACF;IACA,MAAMC,OAAO,GAAG,MAAMjC,WAAW,CAACC,IAAI,CAAC;IACvCE,OAAO,CAACC,GAAG,CAAC,oBAAoBiB,MAAM,CAACC,IAAI,CAACW,OAAO,CAACrB,KAAK,CAAC,CAACW,MAAM,kBAAkB,CAAC;;IAEpF;IACA,MAAM;MAAEX,KAAK;MAAEsB;IAAkB,CAAC,GAAGpD,cAAc,CAACgD,KAAK,CAAC;IAC1D3B,OAAO,CAACC,GAAG,CAAC,iBAAiB0B,KAAK,eAAe,EAAElB,KAAK,CAAC;;IAEzD;IACA,KAAK,MAAMuB,OAAO,IAAIvB,KAAK,EAAE;MAC3B,MAAMwB,IAAI,GAAGvD,aAAa,CAACsD,OAAO,CAAC;MACnChC,OAAO,CAACC,GAAG,CAAC,oBAAoB+B,OAAO,mBAAmBC,IAAI,IAAI,CAAC;;MAEnE;MACA,IAAI,CAACzD,gBAAgB,CAACyD,IAAI,CAAC,EAAE;QAC3BjC,OAAO,CAACC,GAAG,CAAC,uBAAuBgC,IAAI,EAAE,CAAC;QAC1CJ,MAAM,CAACK,IAAI,CAAC,iGAAiGF,OAAO,EAAE,CAAC;QACvH;MACF;MAEAhC,OAAO,CAACC,GAAG,CAAC,qBAAqBgC,IAAI,qCAAqC,CAAC;;MAE3E;MACA,IAAIH,OAAO,CAACrB,KAAK,CAACwB,IAAI,CAAC,EAAE;QACvBjC,OAAO,CAACC,GAAG,CAAC,QAAQgC,IAAI,oBAAoB,CAAC;QAC7CL,OAAO,CAACM,IAAI,CAAC;UACXC,IAAI,EAAEF,IAAI;UACVG,YAAY,EAAEN,OAAO,CAACrB,KAAK,CAACwB,IAAI,CAAC,CAACG,YAAY;UAC9CC,MAAM,EAAEpD,YAAY,CAACgD,IAAI,EAAEH,OAAO,CAACjB,MAAM,CAAC;UAC1CyB,OAAO,EAAEtD,cAAc,CAACiD,IAAI,EAAEH,OAAO,CAACrB,KAAK,EAAEqB,OAAO,CAAChB,QAAQ;QAC/D,CAAC,CAAC;MACJ,CAAC,MAAM;QACLd,OAAO,CAACC,GAAG,CAAC,QAAQgC,IAAI,kDAAkD,CAAC;;QAE3E;QACA,MAAMM,UAAU,GAAGzD,iBAAiB,CAACmD,IAAI,EAAEH,OAAO,CAACrB,KAAK,CAAC;QACzDT,OAAO,CAACC,GAAG,CAAC,SAASsC,UAAU,CAACnB,MAAM,oBAAoBa,IAAI,EAAE,CAAC;QAEjE,IAAIM,UAAU,CAACnB,MAAM,GAAG,CAAC,EAAE;UACzB;UACAmB,UAAU,CAACC,OAAO,CAACC,SAAS,IAAI;YAC9Bb,OAAO,CAACM,IAAI,CAAC;cACXC,IAAI,EAAEM,SAAS;cACfL,YAAY,EAAEN,OAAO,CAACrB,KAAK,CAACgC,SAAS,CAAC,CAACL,YAAY;cACnDC,MAAM,EAAEpD,YAAY,CAACwD,SAAS,EAAEX,OAAO,CAACjB,MAAM,CAAC;cAC/CyB,OAAO,EAAEtD,cAAc,CAACyD,SAAS,EAAEX,OAAO,CAACrB,KAAK,EAAEqB,OAAO,CAAChB,QAAQ;YACpE,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ,CAAC,MAAM;UACLe,MAAM,CAACK,IAAI,CAAC,0BAA0BpC,IAAI,eAAekC,OAAO,EAAE,CAAC;QACrE;MACF;IACF;IAEAhC,OAAO,CAACC,GAAG,CAAC,8BAA8B2B,OAAO,CAACR,MAAM,UAAU,CAAC;IACnE,OAAO;MACLQ,OAAO;MACPG,iBAAiB;MACjBF;IACF,CAAC;EACH,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClDwB,MAAM,CAACK,IAAI,CAAC,yBAAyB7B,KAAK,CAACqC,OAAO,EAAE,CAAC;IACrD,OAAO;MAAEd,OAAO;MAAEG,iBAAiB,EAAE,CAAC;MAAEF;IAAO,CAAC;EAClD;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMc,cAAc,GAAG,MAAAA,CAAOhB,KAAK,EAAE7B,IAAI,KAAK;EACnD,MAAM8B,OAAO,GAAG,EAAE;EAClB,MAAMC,MAAM,GAAG,EAAE;EAEjB,IAAI;IACF;IACA,MAAMe,OAAO,GAAG,MAAMtB,WAAW,CAACxB,IAAI,CAAC;;IAEvC;IACA,MAAM;MAAEW,KAAK;MAAEsB;IAAkB,CAAC,GAAGpD,cAAc,CAACgD,KAAK,CAAC;;IAE1D;IACA,KAAK,MAAMK,OAAO,IAAIvB,KAAK,EAAE;MAC3B,MAAMwB,IAAI,GAAGvD,aAAa,CAACsD,OAAO,CAAC;;MAEnC;MACA,IAAIpD,gBAAgB,CAACqD,IAAI,CAAC,EAAE;QAC1B,MAAMY,YAAY,GAAGhE,mBAAmB,CAACoD,IAAI,EAAEW,OAAO,CAACnC,KAAK,CAAC;QAE7D,IAAIoC,YAAY,CAACzB,MAAM,KAAK,CAAC,EAAE;UAC7BS,MAAM,CAACK,IAAI,CAAC,yCAAyCF,OAAO,EAAE,CAAC;QACjE,CAAC,MAAM;UACLa,YAAY,CAACL,OAAO,CAACM,WAAW,IAAI;YAClC,MAAMC,QAAQ,GAAGH,OAAO,CAACnC,KAAK,CAACqC,WAAW,CAAC;YAC3ClB,OAAO,CAACM,IAAI,CAAC;cACXC,IAAI,EAAEW,WAAW;cACjBV,YAAY,EAAEW,QAAQ,CAACX,YAAY;cACnCC,MAAM,EAAElD,YAAY,CAAC2D,WAAW,EAAEF,OAAO,CAAC/B,MAAM,CAAC;cACjDyB,OAAO,EAAEpD,cAAc,CAAC4D,WAAW,EAAEF,OAAO,CAAC9B,QAAQ,CAAC;cACtDW,WAAW,EAAErC,kBAAkB,CAAC0D,WAAW,EAAEF,OAAO,CAACnB,WAAW;YAClE,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ;QACA;MACF;;MAEA;MACA,IAAI,CAAChD,gBAAgB,CAACwD,IAAI,CAAC,EAAE;QAC3BJ,MAAM,CAACK,IAAI,CAAC,qGAAqGF,OAAO,EAAE,CAAC;QAC3H;MACF;;MAEA;MACA,IAAIY,OAAO,CAACnC,KAAK,CAACwB,IAAI,CAAC,EAAE;QACvBL,OAAO,CAACM,IAAI,CAAC;UACXC,IAAI,EAAEF,IAAI;UACVG,YAAY,EAAEQ,OAAO,CAACnC,KAAK,CAACwB,IAAI,CAAC,CAACG,YAAY;UAC9CC,MAAM,EAAElD,YAAY,CAAC8C,IAAI,EAAEW,OAAO,CAAC/B,MAAM,CAAC;UAC1CyB,OAAO,EAAEpD,cAAc,CAAC+C,IAAI,EAAEW,OAAO,CAAC9B,QAAQ,CAAC;UAC/CW,WAAW,EAAErC,kBAAkB,CAAC6C,IAAI,EAAEW,OAAO,CAACnB,WAAW;QAC3D,CAAC,CAAC;MACJ,CAAC,MAAM;QACL;QACA,MAAMc,UAAU,GAAGxD,iBAAiB,CAACkD,IAAI,EAAEW,OAAO,CAACnC,KAAK,CAAC;QAEzD,IAAI8B,UAAU,CAACnB,MAAM,GAAG,CAAC,EAAE;UACzB;UACAmB,UAAU,CAACC,OAAO,CAACC,SAAS,IAAI;YAC9Bb,OAAO,CAACM,IAAI,CAAC;cACXC,IAAI,EAAEM,SAAS;cACfL,YAAY,EAAEQ,OAAO,CAACnC,KAAK,CAACgC,SAAS,CAAC,CAACL,YAAY;cACnDC,MAAM,EAAElD,YAAY,CAACsD,SAAS,EAAEG,OAAO,CAAC/B,MAAM,CAAC;cAC/CyB,OAAO,EAAEpD,cAAc,CAACuD,SAAS,EAAEG,OAAO,CAAC9B,QAAQ,CAAC;cACpDW,WAAW,EAAErC,kBAAkB,CAACqD,SAAS,EAAEG,OAAO,CAACnB,WAAW;YAChE,CAAC,CAAC;UACJ,CAAC,CAAC;QACJ,CAAC,MAAM;UACLI,MAAM,CAACK,IAAI,CAAC,0BAA0BpC,IAAI,eAAekC,OAAO,EAAE,CAAC;QACrE;MACF;IACF;IAEA,OAAO;MACLJ,OAAO;MACPG,iBAAiB;MACjBF;IACF,CAAC;EACH,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClDwB,MAAM,CAACK,IAAI,CAAC,yBAAyB7B,KAAK,CAACqC,OAAO,EAAE,CAAC;IACrD,OAAO;MAAEd,OAAO;MAAEG,iBAAiB,EAAE,CAAC;MAAEF;IAAO,CAAC;EAClD;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}