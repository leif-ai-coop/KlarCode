{"ast":null,"code":"import { parseICDCodes, parseICDGroups, parseICDChapters, parseOPSCodes, parseOPSGroups, parseOPSChapters, parseOPSDreisteller } from '../utils/parser';\nimport { isValidICDFormat, isValidOPSFormat, normalizeCode, parseUserInput, isWildcardSearch, findWildcardMatches, findChildICDCodes, findChildOPSCodes, findICDChapter, findICDGroup, findOPSChapter, findOPSGroup, findOPSDreisteller, detectCodeType, formatOPSCode, findDreistellerRange } from '../utils/search';\n\n// Cache für geladene Daten\nconst dataCache = {\n  icd: {},\n  ops: {}\n};\n\n/**\r\n * Get the current year or fallback to 2025 if not available\r\n * @returns {string} - The current year\r\n */\nexport const getCurrentYear = () => {\n  const currentYear = new Date().getFullYear();\n  return currentYear >= 2025 && currentYear <= 2026 ? currentYear.toString() : '2025';\n};\n\n/**\r\n * Load all ICD-10 data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\nexport const loadICDData = async year => {\n  // Check if data is already cached\n  if (dataCache.icd[year]) {\n    return dataCache.icd[year];\n  }\n  try {\n    // Verschiedene Pfadvarianten testen\n    let baseUrl = `/data/${year}/icd10/`;\n\n    // Logging hinzufügen, um das Problem besser zu verstehen\n    console.log(`Attempting to load ICD data from: ${baseUrl}`);\n\n    // Load all required files\n    const codesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\n    if (!codesResponse.ok) {\n      console.error(`Failed to load ICD-10 codes: ${codesResponse.status}, trying alternative path...`);\n\n      // Alternative paths to try\n      baseUrl = `/src/data/${year}/icd10/`;\n      console.log(`Trying alternative path: ${baseUrl}`);\n      const altCodesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\n      if (!altCodesResponse.ok) {\n        console.error(`Failed to load ICD-10 codes from alternative path: ${altCodesResponse.status}`);\n        throw new Error(`Failed to load ICD-10 data for ${year}`);\n      }\n      console.log(\"Successfully loaded ICD data from alternative path!\");\n      const codes = parseICDCodes(await altCodesResponse.text());\n\n      // Load other files\n      const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\n      const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\n      if (!groupsResponse.ok || !chaptersResponse.ok) {\n        throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\n      }\n      const groups = parseICDGroups(await groupsResponse.text());\n      const chapters = parseICDChapters(await chaptersResponse.text());\n\n      // Cache the data\n      dataCache.icd[year] = {\n        codes,\n        groups,\n        chapters\n      };\n      return dataCache.icd[year];\n    }\n\n    // Ursprünglicher Code für den Fall, dass der erste Pfad funktioniert\n    console.log(\"Successfully loaded ICD data from original path!\");\n    const codesText = await codesResponse.text();\n    const codes = parseICDCodes(codesText);\n    const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\n    const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\n    if (!groupsResponse.ok || !chaptersResponse.ok) {\n      throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\n    }\n    const groupsText = await groupsResponse.text();\n    const chaptersText = await chaptersResponse.text();\n\n    // Parse the data\n    const groups = parseICDGroups(groupsText);\n    const chapters = parseICDChapters(chaptersText);\n\n    // Cache the data\n    dataCache.icd[year] = {\n      codes,\n      groups,\n      chapters\n    };\n\n    // Datenzusammenfassung ausgeben\n    console.log(`Loaded ${Object.keys(codes).length} ICD codes`);\n    console.log(`Sample codes:`, Object.keys(codes).slice(0, 5));\n    return dataCache.icd[year];\n  } catch (error) {\n    console.error(`Error loading ICD data for ${year}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Load all OPS data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\nexport const loadOPSData = async year => {\n  // Check if data is already cached\n  if (dataCache.ops[year]) {\n    return dataCache.ops[year];\n  }\n  try {\n    // Load all required files\n    const codesResponse = await fetch(`/data/${year}/ops/ops${year}syst_kodes.txt`);\n    const groupsResponse = await fetch(`/data/${year}/ops/ops${year}syst_gruppen.txt`);\n    const chaptersResponse = await fetch(`/data/${year}/ops/ops${year}syst_kapitel.txt`);\n    const dreistellerResponse = await fetch(`/data/${year}/ops/ops${year}syst_dreisteller.txt`);\n    if (!codesResponse.ok || !groupsResponse.ok || !chaptersResponse.ok || !dreistellerResponse.ok) {\n      throw new Error(`Failed to load OPS data for ${year}`);\n    }\n    const codesText = await codesResponse.text();\n    const groupsText = await groupsResponse.text();\n    const chaptersText = await chaptersResponse.text();\n    const dreistellerText = await dreistellerResponse.text();\n\n    // Parse the data\n    const codes = parseOPSCodes(codesText);\n    const groups = parseOPSGroups(groupsText);\n    const chapters = parseOPSChapters(chaptersText);\n    const dreisteller = parseOPSDreisteller(dreistellerText);\n\n    // Cache the data\n    dataCache.ops[year] = {\n      codes,\n      groups,\n      chapters,\n      dreisteller\n    };\n    return dataCache.ops[year];\n  } catch (error) {\n    console.error(`Error loading OPS data for ${year}:`, error);\n    throw error;\n  }\n};\n\n/**\r\n * Search for ICD-10 codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\nexport const searchICDCodes = async (input, year) => {\n  const results = [];\n  const errors = [];\n  try {\n    // Load or get cached data\n    const icdData = await loadICDData(year);\n    console.log(`ICD Data loaded, ${Object.keys(icdData.codes).length} codes available`);\n\n    // Parse user input\n    const {\n      codes,\n      duplicatesRemoved\n    } = parseUserInput(input);\n    console.log(`Parsed input \"${input}\" into codes for ICD search:`, codes);\n\n    // Process each code\n    for (const rawCode of codes) {\n      const code = normalizeCode(rawCode);\n\n      // Skip non-ICD codes\n      if (detectCodeType(code) !== 'icd') {\n        console.log(`Skipping non-ICD code: ${code}`);\n        continue;\n      }\n      console.log(`Processing ICD code \"${rawCode}\" (normalized: \"${code}\")`);\n\n      // Handle wildcard search\n      if (isWildcardSearch(code)) {\n        const matchedCodes = findWildcardMatches(code, icdData.codes);\n        if (matchedCodes.length === 0) {\n          errors.push(`Keine passenden ICD-Codes für Muster: ${rawCode}`);\n        } else {\n          matchedCodes.forEach(matchedCode => {\n            const codeData = icdData.codes[matchedCode];\n            results.push({\n              kode: matchedCode,\n              beschreibung: codeData.beschreibung,\n              gruppe: findICDGroup(matchedCode, icdData.groups),\n              kapitel: findICDChapter(matchedCode, icdData.codes, icdData.chapters),\n              isParent: true\n            });\n          });\n        }\n        continue;\n      }\n\n      // Validate code format\n      if (!isValidICDFormat(code)) {\n        errors.push(`Formatfehler: ICD-Codes müssen im Format A00, A00.1 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\n        continue;\n      }\n\n      // Check if code exists directly\n      if (icdData.codes[code]) {\n        const codeData = icdData.codes[code];\n\n        // Wenn es ein nicht-endstelliger Code ist oder explizit als solcher markiert ist\n        if (codeData.isNonTerminal || !code.includes('.')) {\n          // Suche nach zugehörigen endstelligen Codes\n          console.log(`${code} ist ein nicht-endstelliger Code, suche nach allen zugehörigen Codes...`);\n          const childCodes = findChildICDCodes(code, icdData.codes);\n          if (childCodes.length > 0) {\n            // Füge den übergeordneten Code hinzu\n            results.push({\n              kode: code,\n              beschreibung: codeData.beschreibung,\n              gruppe: findICDGroup(code, icdData.groups),\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters),\n              isParent: true // Markieren als übergeordneten Code\n            });\n\n            // Füge alle endstelligen Codes hinzu\n            childCodes.forEach(childCode => {\n              // Überspringe den übergeordneten Code selbst in der Kindliste\n              if (childCode === code) return;\n              results.push({\n                kode: childCode,\n                beschreibung: icdData.codes[childCode].beschreibung,\n                gruppe: findICDGroup(childCode, icdData.groups),\n                kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\n                parentCode: code // Referenz zum übergeordneten Code\n              });\n            });\n          } else {\n            // Wenn keine Kinder gefunden wurden, füge nur den Code selbst hinzu\n            results.push({\n              kode: code,\n              beschreibung: codeData.beschreibung,\n              gruppe: findICDGroup(code, icdData.groups),\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\n            });\n          }\n        } else {\n          // Für endstellige Codes füge einfach den Code selbst hinzu\n          results.push({\n            kode: code,\n            beschreibung: codeData.beschreibung,\n            gruppe: findICDGroup(code, icdData.groups),\n            kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\n          });\n        }\n      } else {\n        // Code nicht direkt gefunden, prüfe ob es ein übergeordneter Code ist\n        const childCodes = findChildICDCodes(code, icdData.codes);\n        if (childCodes.length > 0) {\n          console.log(`${code} wurde nicht direkt gefunden, aber ${childCodes.length} zugehörige Codes`);\n          // Füge alle gefundenen Kinder hinzu\n          childCodes.forEach(childCode => {\n            results.push({\n              kode: childCode,\n              beschreibung: icdData.codes[childCode].beschreibung,\n              gruppe: findICDGroup(childCode, icdData.groups),\n              kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\n              fromParent: code // Markieren, aus welchem übergeordneten Code dieser stammt\n            });\n          });\n        } else {\n          errors.push(`ICD-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n        }\n      }\n    }\n    console.log(`ICD search complete, found ${results.length} results`);\n    return {\n      results,\n      duplicatesRemoved,\n      errors\n    };\n  } catch (error) {\n    console.error('Error searching ICD codes:', error);\n    errors.push(`Fehler bei der Suche: ${error.message}`);\n    return {\n      results,\n      duplicatesRemoved: 0,\n      errors\n    };\n  }\n};\n\n/**\r\n * Search for OPS codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @param {boolean} showChildCodes - Whether to include child codes in results (default: false)\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\nexport const searchOPSCodes = async (input, year, showChildCodes = false) => {\n  const results = [];\n  const errors = [];\n  try {\n    // Load or get cached data\n    const opsData = await loadOPSData(year);\n    console.log(`OPS Data loaded, ${Object.keys(opsData.codes).length} codes available`);\n\n    // Parse user input\n    const {\n      codes,\n      duplicatesRemoved\n    } = parseUserInput(input);\n    console.log(`Parsed input \"${input}\" into codes for OPS search:`, codes);\n\n    // Process each code\n    for (const rawCode of codes) {\n      const code = normalizeCode(rawCode);\n\n      // Skip non-OPS codes\n      if (detectCodeType(code) !== 'ops') {\n        console.log(`Skipping non-OPS code: ${code}`);\n        continue;\n      }\n\n      // Formatieren des OPS-Codes\n      const formattedCode = formatOPSCode(code);\n      console.log(`Processing OPS code \"${rawCode}\" (normalized: \"${code}\", formatted: \"${formattedCode}\")`);\n\n      // Handle wildcard search\n      if (isWildcardSearch(formattedCode)) {\n        const matchedCodes = findWildcardMatches(formattedCode, opsData.codes);\n        if (matchedCodes.length === 0) {\n          errors.push(`Keine passenden OPS-Codes für Muster: ${rawCode}`);\n        } else {\n          matchedCodes.forEach(matchedCode => {\n            var _findDreistellerRange;\n            const codeData = opsData.codes[matchedCode];\n            results.push({\n              kode: matchedCode,\n              beschreibung: codeData.beschreibung,\n              gruppe: findOPSGroup(matchedCode, opsData.groups),\n              kapitel: findOPSChapter(matchedCode, opsData.chapters),\n              dreisteller: ((_findDreistellerRange = findDreistellerRange(formattedCode, opsData.dreisteller)) === null || _findDreistellerRange === void 0 ? void 0 : _findDreistellerRange.description) || '',\n              isParent: codeData.isNonTerminal\n            });\n          });\n        }\n        continue;\n      }\n\n      // Validate code format\n      if (!isValidOPSFormat(formattedCode)) {\n        errors.push(`Formatfehler: OPS-Codes müssen im Format 1-20, 1-202.00 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\n        continue;\n      }\n\n      // Check if code exists directly\n      if (opsData.codes[formattedCode]) {\n        const codeData = opsData.codes[formattedCode];\n\n        // Finde den Dreisteller-Bereich\n        const dreistellerInfo = findDreistellerRange(formattedCode, opsData.dreisteller);\n\n        // Füge den Hauptcode immer zu den Ergebnissen hinzu\n        results.push({\n          kode: formattedCode,\n          beschreibung: codeData.beschreibung,\n          gruppe: findOPSGroup(formattedCode, opsData.groups),\n          kapitel: findOPSChapter(formattedCode, opsData.chapters),\n          dreisteller: dreistellerInfo ? dreistellerInfo.description : '',\n          isParent: codeData.isNonTerminal\n        });\n\n        // Wenn es ein übergeordneter Code ist und showChildCodes aktiviert ist,\n        // finde und füge alle Kindcodes hinzu\n        if (showChildCodes && codeData.isNonTerminal) {\n          console.log(`${formattedCode} ist ein nicht-endstelliger OPS-Code, suche nach allen zugehörigen Codes...`);\n          const childCodes = findChildOPSCodes(formattedCode, opsData.codes);\n          if (childCodes.length > 0) {\n            // Füge alle endstelligen Codes hinzu\n            childCodes.forEach(childCode => {\n              // Überspringe den übergeordneten Code selbst in der Kindliste\n              if (childCode === formattedCode) return;\n              const childDreistellerInfo = findDreistellerRange(childCode, opsData.dreisteller);\n              results.push({\n                kode: childCode,\n                beschreibung: opsData.codes[childCode].beschreibung,\n                gruppe: findOPSGroup(childCode, opsData.groups),\n                kapitel: findOPSChapter(childCode, opsData.chapters),\n                dreisteller: childDreistellerInfo ? childDreistellerInfo.description : '',\n                parentCode: formattedCode // Referenz zum übergeordneten Code\n              });\n            });\n          }\n        }\n      } else {\n        // Wenn der Code nicht direkt gefunden wurde, prüfe auf Dreisteller\n        const dreistellerMatch = formattedCode.match(/^(\\d-\\d{2})$/);\n        if (dreistellerMatch) {\n          const dreistellerCode = dreistellerMatch[1];\n          const dreistellerInfo = findDreistellerRange(dreistellerCode, opsData.dreisteller);\n          if (dreistellerInfo) {\n            // Füge den Dreisteller selbst hinzu\n            results.push({\n              kode: dreistellerCode,\n              beschreibung: dreistellerInfo.description,\n              gruppe: dreistellerInfo.description,\n              kapitel: findOPSChapter(dreistellerCode, opsData.chapters),\n              dreisteller: dreistellerInfo.description,\n              isParent: true\n            });\n\n            // Finde alle Kindcodes dieses Dreistellercodes, aber nur wenn showChildCodes aktiviert ist\n            if (showChildCodes) {\n              const childPattern = new RegExp(`^${dreistellerCode}\\\\d`);\n              const childCodes = Object.keys(opsData.codes).filter(code => childPattern.test(code));\n              if (childCodes.length > 0) {\n                childCodes.forEach(childCode => {\n                  const childData = opsData.codes[childCode];\n                  results.push({\n                    kode: childCode,\n                    beschreibung: childData.beschreibung,\n                    gruppe: dreistellerInfo.description,\n                    kapitel: findOPSChapter(childCode, opsData.chapters),\n                    dreisteller: dreistellerInfo.description,\n                    parentCode: dreistellerCode\n                  });\n                });\n              }\n            }\n          } else {\n            errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n          }\n        } else {\n          errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\n        }\n      }\n    }\n    console.log(`OPS search complete, found ${results.length} results`);\n    return {\n      results,\n      duplicatesRemoved,\n      errors\n    };\n  } catch (error) {\n    console.error('Error searching OPS codes:', error);\n    errors.push(`Fehler bei der Suche: ${error.message}`);\n    return {\n      results,\n      duplicatesRemoved: 0,\n      errors\n    };\n  }\n};","map":{"version":3,"names":["parseICDCodes","parseICDGroups","parseICDChapters","parseOPSCodes","parseOPSGroups","parseOPSChapters","parseOPSDreisteller","isValidICDFormat","isValidOPSFormat","normalizeCode","parseUserInput","isWildcardSearch","findWildcardMatches","findChildICDCodes","findChildOPSCodes","findICDChapter","findICDGroup","findOPSChapter","findOPSGroup","findOPSDreisteller","detectCodeType","formatOPSCode","findDreistellerRange","dataCache","icd","ops","getCurrentYear","currentYear","Date","getFullYear","toString","loadICDData","year","baseUrl","console","log","codesResponse","fetch","ok","error","status","altCodesResponse","Error","codes","text","groupsResponse","chaptersResponse","groups","chapters","codesText","groupsText","chaptersText","Object","keys","length","slice","loadOPSData","dreistellerResponse","dreistellerText","dreisteller","searchICDCodes","input","results","errors","icdData","duplicatesRemoved","rawCode","code","matchedCodes","push","forEach","matchedCode","codeData","kode","beschreibung","gruppe","kapitel","isParent","isNonTerminal","includes","childCodes","childCode","parentCode","fromParent","message","searchOPSCodes","showChildCodes","opsData","formattedCode","_findDreistellerRange","description","dreistellerInfo","childDreistellerInfo","dreistellerMatch","match","dreistellerCode","childPattern","RegExp","filter","test","childData"],"sources":["C:/Code/KlarCode/src/services/dataService.js"],"sourcesContent":["import { \r\n  parseICDCodes, \r\n  parseICDGroups, \r\n  parseICDChapters,\r\n  parseOPSCodes,\r\n  parseOPSGroups,\r\n  parseOPSChapters,\r\n  parseOPSDreisteller\r\n} from '../utils/parser';\r\n\r\nimport {\r\n  isValidICDFormat,\r\n  isValidOPSFormat,\r\n  normalizeCode,\r\n  parseUserInput,\r\n  isWildcardSearch,\r\n  findWildcardMatches,\r\n  findChildICDCodes,\r\n  findChildOPSCodes,\r\n  findICDChapter,\r\n  findICDGroup,\r\n  findOPSChapter,\r\n  findOPSGroup,\r\n  findOPSDreisteller,\r\n  detectCodeType,\r\n  formatOPSCode,\r\n  findDreistellerRange\r\n} from '../utils/search';\r\n\r\n// Cache für geladene Daten\r\nconst dataCache = {\r\n  icd: {},\r\n  ops: {}\r\n};\r\n\r\n/**\r\n * Get the current year or fallback to 2025 if not available\r\n * @returns {string} - The current year\r\n */\r\nexport const getCurrentYear = () => {\r\n  const currentYear = new Date().getFullYear();\r\n  return currentYear >= 2025 && currentYear <= 2026 ? currentYear.toString() : '2025';\r\n};\r\n\r\n/**\r\n * Load all ICD-10 data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\r\nexport const loadICDData = async (year) => {\r\n  // Check if data is already cached\r\n  if (dataCache.icd[year]) {\r\n    return dataCache.icd[year];\r\n  }\r\n  \r\n  try {\r\n    // Verschiedene Pfadvarianten testen\r\n    let baseUrl = `/data/${year}/icd10/`;\r\n    \r\n    // Logging hinzufügen, um das Problem besser zu verstehen\r\n    console.log(`Attempting to load ICD data from: ${baseUrl}`);\r\n    \r\n    // Load all required files\r\n    const codesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\r\n    \r\n    if (!codesResponse.ok) {\r\n      console.error(`Failed to load ICD-10 codes: ${codesResponse.status}, trying alternative path...`);\r\n      \r\n      // Alternative paths to try\r\n      baseUrl = `/src/data/${year}/icd10/`;\r\n      console.log(`Trying alternative path: ${baseUrl}`);\r\n      \r\n      const altCodesResponse = await fetch(`${baseUrl}icd10gm${year}syst_kodes.txt`);\r\n      \r\n      if (!altCodesResponse.ok) {\r\n        console.error(`Failed to load ICD-10 codes from alternative path: ${altCodesResponse.status}`);\r\n        throw new Error(`Failed to load ICD-10 data for ${year}`);\r\n      }\r\n      \r\n      console.log(\"Successfully loaded ICD data from alternative path!\");\r\n      const codes = parseICDCodes(await altCodesResponse.text());\r\n      \r\n      // Load other files\r\n      const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\r\n      const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\r\n      \r\n      if (!groupsResponse.ok || !chaptersResponse.ok) {\r\n        throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\r\n      }\r\n      \r\n      const groups = parseICDGroups(await groupsResponse.text());\r\n      const chapters = parseICDChapters(await chaptersResponse.text());\r\n      \r\n      // Cache the data\r\n      dataCache.icd[year] = { codes, groups, chapters };\r\n      \r\n      return dataCache.icd[year];\r\n    }\r\n    \r\n    // Ursprünglicher Code für den Fall, dass der erste Pfad funktioniert\r\n    console.log(\"Successfully loaded ICD data from original path!\");\r\n    const codesText = await codesResponse.text();\r\n    const codes = parseICDCodes(codesText);\r\n    \r\n    const groupsResponse = await fetch(`${baseUrl}icd10gm${year}syst_gruppen.txt`);\r\n    const chaptersResponse = await fetch(`${baseUrl}icd10gm${year}syst_kapitel.txt`);\r\n    \r\n    if (!groupsResponse.ok || !chaptersResponse.ok) {\r\n      throw new Error(`Failed to load ICD-10 groups or chapters for ${year}`);\r\n    }\r\n    \r\n    const groupsText = await groupsResponse.text();\r\n    const chaptersText = await chaptersResponse.text();\r\n    \r\n    // Parse the data\r\n    const groups = parseICDGroups(groupsText);\r\n    const chapters = parseICDChapters(chaptersText);\r\n    \r\n    // Cache the data\r\n    dataCache.icd[year] = { codes, groups, chapters };\r\n    \r\n    // Datenzusammenfassung ausgeben\r\n    console.log(`Loaded ${Object.keys(codes).length} ICD codes`);\r\n    console.log(`Sample codes:`, Object.keys(codes).slice(0, 5));\r\n    \r\n    return dataCache.icd[year];\r\n  } catch (error) {\r\n    console.error(`Error loading ICD data for ${year}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Load all OPS data for a specific year\r\n * @param {string} year - The year to load data for\r\n * @returns {Promise} - Promise resolving to the loaded data\r\n */\r\nexport const loadOPSData = async (year) => {\r\n  // Check if data is already cached\r\n  if (dataCache.ops[year]) {\r\n    return dataCache.ops[year];\r\n  }\r\n  \r\n  try {\r\n    // Load all required files\r\n    const codesResponse = await fetch(`/data/${year}/ops/ops${year}syst_kodes.txt`);\r\n    const groupsResponse = await fetch(`/data/${year}/ops/ops${year}syst_gruppen.txt`);\r\n    const chaptersResponse = await fetch(`/data/${year}/ops/ops${year}syst_kapitel.txt`);\r\n    const dreistellerResponse = await fetch(`/data/${year}/ops/ops${year}syst_dreisteller.txt`);\r\n    \r\n    if (!codesResponse.ok || !groupsResponse.ok || !chaptersResponse.ok || !dreistellerResponse.ok) {\r\n      throw new Error(`Failed to load OPS data for ${year}`);\r\n    }\r\n    \r\n    const codesText = await codesResponse.text();\r\n    const groupsText = await groupsResponse.text();\r\n    const chaptersText = await chaptersResponse.text();\r\n    const dreistellerText = await dreistellerResponse.text();\r\n    \r\n    // Parse the data\r\n    const codes = parseOPSCodes(codesText);\r\n    const groups = parseOPSGroups(groupsText);\r\n    const chapters = parseOPSChapters(chaptersText);\r\n    const dreisteller = parseOPSDreisteller(dreistellerText);\r\n    \r\n    // Cache the data\r\n    dataCache.ops[year] = { codes, groups, chapters, dreisteller };\r\n    \r\n    return dataCache.ops[year];\r\n  } catch (error) {\r\n    console.error(`Error loading OPS data for ${year}:`, error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Search for ICD-10 codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\r\nexport const searchICDCodes = async (input, year) => {\r\n  const results = [];\r\n  const errors = [];\r\n  \r\n  try {\r\n    // Load or get cached data\r\n    const icdData = await loadICDData(year);\r\n    console.log(`ICD Data loaded, ${Object.keys(icdData.codes).length} codes available`);\r\n    \r\n    // Parse user input\r\n    const { codes, duplicatesRemoved } = parseUserInput(input);\r\n    console.log(`Parsed input \"${input}\" into codes for ICD search:`, codes);\r\n    \r\n    // Process each code\r\n    for (const rawCode of codes) {\r\n      const code = normalizeCode(rawCode);\r\n      \r\n      // Skip non-ICD codes\r\n      if (detectCodeType(code) !== 'icd') {\r\n        console.log(`Skipping non-ICD code: ${code}`);\r\n        continue;\r\n      }\r\n      \r\n      console.log(`Processing ICD code \"${rawCode}\" (normalized: \"${code}\")`);\r\n      \r\n      // Handle wildcard search\r\n      if (isWildcardSearch(code)) {\r\n        const matchedCodes = findWildcardMatches(code, icdData.codes);\r\n        \r\n        if (matchedCodes.length === 0) {\r\n          errors.push(`Keine passenden ICD-Codes für Muster: ${rawCode}`);\r\n        } else {\r\n          matchedCodes.forEach(matchedCode => {\r\n            const codeData = icdData.codes[matchedCode];\r\n            results.push({\r\n              kode: matchedCode,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findICDGroup(matchedCode, icdData.groups),\r\n              kapitel: findICDChapter(matchedCode, icdData.codes, icdData.chapters),\r\n              isParent: true\r\n            });\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n      \r\n      // Validate code format\r\n      if (!isValidICDFormat(code)) {\r\n        errors.push(`Formatfehler: ICD-Codes müssen im Format A00, A00.1 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\r\n        continue;\r\n      }\r\n      \r\n      // Check if code exists directly\r\n      if (icdData.codes[code]) {\r\n        const codeData = icdData.codes[code];\r\n        \r\n        // Wenn es ein nicht-endstelliger Code ist oder explizit als solcher markiert ist\r\n        if (codeData.isNonTerminal || !code.includes('.')) {\r\n          // Suche nach zugehörigen endstelligen Codes\r\n          console.log(`${code} ist ein nicht-endstelliger Code, suche nach allen zugehörigen Codes...`);\r\n          const childCodes = findChildICDCodes(code, icdData.codes);\r\n          \r\n          if (childCodes.length > 0) {\r\n            // Füge den übergeordneten Code hinzu\r\n            results.push({\r\n              kode: code,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findICDGroup(code, icdData.groups),\r\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters),\r\n              isParent: true // Markieren als übergeordneten Code\r\n            });\r\n            \r\n            // Füge alle endstelligen Codes hinzu\r\n            childCodes.forEach(childCode => {\r\n              // Überspringe den übergeordneten Code selbst in der Kindliste\r\n              if (childCode === code) return;\r\n              \r\n              results.push({\r\n                kode: childCode,\r\n                beschreibung: icdData.codes[childCode].beschreibung,\r\n                gruppe: findICDGroup(childCode, icdData.groups),\r\n                kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\r\n                parentCode: code // Referenz zum übergeordneten Code\r\n              });\r\n            });\r\n          } else {\r\n            // Wenn keine Kinder gefunden wurden, füge nur den Code selbst hinzu\r\n            results.push({\r\n              kode: code,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findICDGroup(code, icdData.groups),\r\n              kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\r\n            });\r\n          }\r\n        } else {\r\n          // Für endstellige Codes füge einfach den Code selbst hinzu\r\n          results.push({\r\n            kode: code,\r\n            beschreibung: codeData.beschreibung,\r\n            gruppe: findICDGroup(code, icdData.groups),\r\n            kapitel: findICDChapter(code, icdData.codes, icdData.chapters)\r\n          });\r\n        }\r\n      } else {\r\n        // Code nicht direkt gefunden, prüfe ob es ein übergeordneter Code ist\r\n        const childCodes = findChildICDCodes(code, icdData.codes);\r\n        \r\n        if (childCodes.length > 0) {\r\n          console.log(`${code} wurde nicht direkt gefunden, aber ${childCodes.length} zugehörige Codes`);\r\n          // Füge alle gefundenen Kinder hinzu\r\n          childCodes.forEach(childCode => {\r\n            results.push({\r\n              kode: childCode,\r\n              beschreibung: icdData.codes[childCode].beschreibung,\r\n              gruppe: findICDGroup(childCode, icdData.groups),\r\n              kapitel: findICDChapter(childCode, icdData.codes, icdData.chapters),\r\n              fromParent: code // Markieren, aus welchem übergeordneten Code dieser stammt\r\n            });\r\n          });\r\n        } else {\r\n          errors.push(`ICD-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`ICD search complete, found ${results.length} results`);\r\n    return {\r\n      results,\r\n      duplicatesRemoved,\r\n      errors\r\n    };\r\n  } catch (error) {\r\n    console.error('Error searching ICD codes:', error);\r\n    errors.push(`Fehler bei der Suche: ${error.message}`);\r\n    return { results, duplicatesRemoved: 0, errors };\r\n  }\r\n};\r\n\r\n/**\r\n * Search for OPS codes\r\n * @param {string} input - User input\r\n * @param {string} year - The year to search in\r\n * @param {boolean} showChildCodes - Whether to include child codes in results (default: false)\r\n * @returns {Promise<SearchResult>} - Promise resolving to search results\r\n */\r\nexport const searchOPSCodes = async (input, year, showChildCodes = false) => {\r\n  const results = [];\r\n  const errors = [];\r\n  \r\n  try {\r\n    // Load or get cached data\r\n    const opsData = await loadOPSData(year);\r\n    console.log(`OPS Data loaded, ${Object.keys(opsData.codes).length} codes available`);\r\n    \r\n    // Parse user input\r\n    const { codes, duplicatesRemoved } = parseUserInput(input);\r\n    console.log(`Parsed input \"${input}\" into codes for OPS search:`, codes);\r\n    \r\n    // Process each code\r\n    for (const rawCode of codes) {\r\n      const code = normalizeCode(rawCode);\r\n      \r\n      // Skip non-OPS codes\r\n      if (detectCodeType(code) !== 'ops') {\r\n        console.log(`Skipping non-OPS code: ${code}`);\r\n        continue;\r\n      }\r\n      \r\n      // Formatieren des OPS-Codes\r\n      const formattedCode = formatOPSCode(code);\r\n      \r\n      console.log(`Processing OPS code \"${rawCode}\" (normalized: \"${code}\", formatted: \"${formattedCode}\")`);\r\n      \r\n      // Handle wildcard search\r\n      if (isWildcardSearch(formattedCode)) {\r\n        const matchedCodes = findWildcardMatches(formattedCode, opsData.codes);\r\n        \r\n        if (matchedCodes.length === 0) {\r\n          errors.push(`Keine passenden OPS-Codes für Muster: ${rawCode}`);\r\n        } else {\r\n          matchedCodes.forEach(matchedCode => {\r\n            const codeData = opsData.codes[matchedCode];\r\n            results.push({\r\n              kode: matchedCode,\r\n              beschreibung: codeData.beschreibung,\r\n              gruppe: findOPSGroup(matchedCode, opsData.groups),\r\n              kapitel: findOPSChapter(matchedCode, opsData.chapters),\r\n              dreisteller: findDreistellerRange(formattedCode, opsData.dreisteller)?.description || '',\r\n              isParent: codeData.isNonTerminal\r\n            });\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n      \r\n      // Validate code format\r\n      if (!isValidOPSFormat(formattedCode)) {\r\n        errors.push(`Formatfehler: OPS-Codes müssen im Format 1-20, 1-202.00 oder ähnlich eingegeben werden. Ungültig: ${rawCode}`);\r\n        continue;\r\n      }\r\n      \r\n      // Check if code exists directly\r\n      if (opsData.codes[formattedCode]) {\r\n        const codeData = opsData.codes[formattedCode];\r\n        \r\n        // Finde den Dreisteller-Bereich\r\n        const dreistellerInfo = findDreistellerRange(formattedCode, opsData.dreisteller);\r\n        \r\n        // Füge den Hauptcode immer zu den Ergebnissen hinzu\r\n        results.push({\r\n          kode: formattedCode,\r\n          beschreibung: codeData.beschreibung,\r\n          gruppe: findOPSGroup(formattedCode, opsData.groups),\r\n          kapitel: findOPSChapter(formattedCode, opsData.chapters),\r\n          dreisteller: dreistellerInfo ? dreistellerInfo.description : '',\r\n          isParent: codeData.isNonTerminal\r\n        });\r\n        \r\n        // Wenn es ein übergeordneter Code ist und showChildCodes aktiviert ist,\r\n        // finde und füge alle Kindcodes hinzu\r\n        if (showChildCodes && codeData.isNonTerminal) {\r\n          console.log(`${formattedCode} ist ein nicht-endstelliger OPS-Code, suche nach allen zugehörigen Codes...`);\r\n          const childCodes = findChildOPSCodes(formattedCode, opsData.codes);\r\n          \r\n          if (childCodes.length > 0) {\r\n            // Füge alle endstelligen Codes hinzu\r\n            childCodes.forEach(childCode => {\r\n              // Überspringe den übergeordneten Code selbst in der Kindliste\r\n              if (childCode === formattedCode) return;\r\n              \r\n              const childDreistellerInfo = findDreistellerRange(childCode, opsData.dreisteller);\r\n              \r\n              results.push({\r\n                kode: childCode,\r\n                beschreibung: opsData.codes[childCode].beschreibung,\r\n                gruppe: findOPSGroup(childCode, opsData.groups),\r\n                kapitel: findOPSChapter(childCode, opsData.chapters),\r\n                dreisteller: childDreistellerInfo ? childDreistellerInfo.description : '',\r\n                parentCode: formattedCode // Referenz zum übergeordneten Code\r\n              });\r\n            });\r\n          }\r\n        }\r\n      } else {\r\n        // Wenn der Code nicht direkt gefunden wurde, prüfe auf Dreisteller\r\n        const dreistellerMatch = formattedCode.match(/^(\\d-\\d{2})$/);\r\n        \r\n        if (dreistellerMatch) {\r\n          const dreistellerCode = dreistellerMatch[1];\r\n          const dreistellerInfo = findDreistellerRange(dreistellerCode, opsData.dreisteller);\r\n          \r\n          if (dreistellerInfo) {\r\n            // Füge den Dreisteller selbst hinzu\r\n            results.push({\r\n              kode: dreistellerCode,\r\n              beschreibung: dreistellerInfo.description,\r\n              gruppe: dreistellerInfo.description,\r\n              kapitel: findOPSChapter(dreistellerCode, opsData.chapters),\r\n              dreisteller: dreistellerInfo.description,\r\n              isParent: true\r\n            });\r\n            \r\n            // Finde alle Kindcodes dieses Dreistellercodes, aber nur wenn showChildCodes aktiviert ist\r\n            if (showChildCodes) {\r\n              const childPattern = new RegExp(`^${dreistellerCode}\\\\d`);\r\n              const childCodes = Object.keys(opsData.codes).filter(code => \r\n                childPattern.test(code)\r\n              );\r\n              \r\n              if (childCodes.length > 0) {\r\n                childCodes.forEach(childCode => {\r\n                  const childData = opsData.codes[childCode];\r\n                  results.push({\r\n                    kode: childCode,\r\n                    beschreibung: childData.beschreibung,\r\n                    gruppe: dreistellerInfo.description,\r\n                    kapitel: findOPSChapter(childCode, opsData.chapters),\r\n                    dreisteller: dreistellerInfo.description,\r\n                    parentCode: dreistellerCode\r\n                  });\r\n                });\r\n              }\r\n            }\r\n          } else {\r\n            errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n          }\r\n        } else {\r\n          errors.push(`OPS-Code nicht im Jahr ${year} vorhanden: ${rawCode}`);\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log(`OPS search complete, found ${results.length} results`);\r\n    return {\r\n      results,\r\n      duplicatesRemoved,\r\n      errors\r\n    };\r\n  } catch (error) {\r\n    console.error('Error searching OPS codes:', error);\r\n    errors.push(`Fehler bei der Suche: ${error.message}`);\r\n    return { results, duplicatesRemoved: 0, errors };\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}